#!/bin/sh

# -----------------------------------------------------------------------------
# Customizable console menu to organize different environment settings
#
# Alex Demyankov
# alex.demyankov@gmail.com
# https://www.linkedin.com/in/ademyankov/
#
# March, 2020
#
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# The global variable that holds the menu object
unset MENUEX
declare -A MENUEX=()

# Change to 'Debug' for logs to be shown
MENUEX['build']='Release'
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
#
# Functions and parameters acronims
#
# [IN]  - input argument
# [OPT] - optional argument
# [OUT] - output result
#
# MENU.Null - is a special string that represents 'no string' for an optional
#             string argument; it can be usefull when an optional string
#             argument is in the middle of the arguments list, For example:
#             "MENU.Create menu1 MENU.Null MENU.Null Menu1Function". In case of
#             "MENU.Create menu1 '' '' Menu1Function" it would be impossible to
#             separate one parameter from the others inside the function
#
# MENU._lover_case - functions, named in such a way, are private and are not
#                    supposed to be called directly, but nothing prevents it
#
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# Pads a string with 'space' chars to the length specified
#
# [IN] string - a string to pad
# [IN] length - the length the output string should be
# [OUT] returns the padded string
#
# -----------------------------------------------------------------------------
MENU._string_pad() {
    local len=$(($2 - ${#1}))
    pad=`printf '%*s' "$len" | tr ' ' " "`
    echo "$1$pad"
}

# -----------------------------------------------------------------------------
# Converts a string to an upper case string
#
# [IN] string - a string to convert
# [OUT] returns the converted string
#
# -----------------------------------------------------------------------------
MENU._to_upper() {
    echo "$(echo ${1} | awk '{print toupper($0)}')"
}

# -----------------------------------------------------------------------------
# Helper functions to display log/trace
#
# [IN] string - a log's mode, supported: {INFO, WARNING, SEVERE}
#
# -----------------------------------------------------------------------------
MENU._log() {
    eval "${MENUEX['styles']}"
    local marker="${styles['green']}${styles['bold']}INFO${styles['reset']}:"
    [[ "$1" == 'WARNING' ]] && marker="${styles['yellow']}${styles['bold']}WARNING${styles['reset']}:"
    [[ "$1" == 'SEVERE' ]] && marker="${styles['red']}${styles['bold']}SEVERE${styles['reset']}:"
    shift
    echo ">${FUNCNAME[2]}: $marker $*"
}

MENU._log_ln() {
    [[ "${MENUEX["build"]}" == 'Debug' ]] && echo ''
}

MENU._log_info() {
    [[ "${MENUEX["build"]}" == 'Debug' ]] && MENU._log INFO $1
}

MENU._log_warning() {
    [[ "${MENUEX["build"]}" == 'Debug' ]] && MENU._log WARNING $1
}

MENU._error() {
  MENU._log SEVERE $1
}

MENU._warning() {
  MENU._log WARNING $1
}

# -----------------------------------------------------------------------------
# Creates a new menu
#
# [IN]      handle   - a name/handle of the menu to be used w/ the API
# [IN][OPT] name     - a displayed name of the menu
# [IN][OPT] alias    - an alias to be created that displays the menu
# [IN][OPT] callback - a function to be called when the menu is displayed
#
# Remark: The 'alias' parameter creates the alias for the menu unless the alias
#         already exists in the environment
#
# When 'callback' function is called it has 2 arguments passed in:
#
# [IN] handle - the menu's name/handle
# [IN] name   - the menu's name (if specified)
#
# -----------------------------------------------------------------------------
MENU.Create() {
    local ctor="MENU._ctor"
    ${ctor}

    if [[ $# -lt 1 ]]; then
        MENU._error "MENU.Create requires more arguments"
        return
    fi

    local -A context=()
    context['name']='MENU.Null'
    context['alias']='MENU.Null'
    context['callback']='MENU.Null'
    context['selected']=''          # curently selected radio.button
    context['item.length.max']=0    # the max char length of an item's name
    context['menu.width']=0         # the length of the longest string in the menu (used for menu's separator)
    context['sub.menus']='declare -a submenus=()'
    context['is.sub.menu']='false'
    context['has.sub.menu']='false'
    context['is.ln.break.last']='false'
    context['parent.menu']=''

    MENU._log_info "args: $*"

    [ $# -gt 1 ] && context['name']=$2
    [ $# -gt 2 ] && context['alias']=$3
    [ $# -gt 3 ] && context['callback']=$4

    local -a items=()
    context['items']=$(declare -p items)

    eval "${MENUEX['map']}"
    map[$1]=$(declare -p context)
    MENUEX['map']=$(declare -p map)

    eval "${MENUEX["order"]}"
    order[${#order[@]}]=$1
    MENUEX['order']=$(declare -p order)

    local default="MENU.SetStyle $1"
    ${default}

    default="MENU.SetStyleEx $1"
    ${default}

    # Create an alias to display the menu
    if [[ "${context['alias']}" != 'MENU.Null' ]]; then
        if [ `alias | grep "alias ${context['alias']}=" | wc -l` != 0 ]; then
            MENU._warning "Alias '${context['alias']}' already exists in the env and will not be reasigned!"
            [ "${MENUEX['build']}" == "Release" ] && return
        fi
        local argc="$1 ${context['name']} ${context['alias']} ${context['callback']}"
        alias "${context['alias']}"="MENU._show ${argc}"
    fi
}

# The menu's class constructor
MENU._ctor() {
    if [[ ! ${MENUEX['styles']} ]]; then
        # Num  Colour    define          R G B
        # 0    black     COLOR_BLACK     0,0,0
        # 1    red       COLOR_RED       1,0,0
        # 2    green     COLOR_GREEN     0,1,0
        # 3    yellow    COLOR_YELLOW    1,1,0
        # 4    blue      COLOR_BLUE      0,0,1
        # 5    magenta   COLOR_MAGENTA   1,0,1
        # 6    cyan      COLOR_CYAN      0,1,1
        # 7    white     COLOR_WHITE     1,1,1

        local -A styles=()
        styles['black']=`tput setaf 0`
        styles['red']=`tput setaf 1`
        styles['green']=`tput setaf 2`
        styles['yellow']=`tput setaf 3`
        styles['blue']=`tput setaf 4`
        styles['magenta']=`tput setaf 5`
        styles['cyan']=`tput setaf 6`
        styles['white']=`tput setaf 7`

        styles['reset']=`tput sgr0`

        styles['bold']=`tput bold`  # Select bold mode
        styles['dim']=`tput dim`    # Select dim (half-bright) mode
        styles['smul']=`tput smul`  # Enable underline mode
        styles['rmul']=`tput rmul`  # Disable underline mode
        styles['smso']=`tput smso`  # Enter standout (bold) mode
        styles['rmso']=`tput rmso`  # Exit standout mode
        styles['rev']=`tput rev`    # Turn on reverse video mode

        MENUEX['styles']=$(declare -p styles)

        # Calculated width of the entire menu
        MENUEX['width.max']=0

        # A map that holds all the menus created
        MENUEX['map']='declare -A map=()'

        # Tracks the order of menus created
        MENUEX['order']='declare -a order=()'
    fi
}

# -----------------------------------------------------------------------------
# Sets the style for the menu
#
# [IN]      handle  - a name/handle of the menu to be used w/ the API
# [IN][OPT] divider - a divider to be used w/ .AddDivider ('|' by default)
#
# [IN][OPT] align   - the menu's items alignment (none by default), supported:
#             by.largest.item - aligns all the menu's items by the length of the
#                               largest item's name
#
# [IN][OPT] color        - the color of the selected item (green by default)
# [IN][OPT] radio.symbol - the symbol for the selected radio.button ('♦' by default)
# [IN][OPT] radio.symbol - the symbol for the cheched check.button ('x' by default)
#
# Remark: 'default' can be passed as any [OPT] argument, which will set the
#         default value for the corresponding style parameter
#
# Example:
#
# > MENU.SetStyle menu1 default default ${red} '○' default
#
# -----------------------------------------------------------------------------
MENU.SetStyle() {
    if [[ $# -lt 1 ]]; then
      MENU._error 'MENU.SetStyle requires more arguments'
      return
    fi

    eval "${MENUEX['map']}"
    eval "${map["$1"]}"

    # By default
    context['divider']='|'
    context['align']='none'
    context['select.color']='green'
    context['radio.button.symbol']='♦'
    context['check.button.symbol']='x'

    # Optional arguments
    [[ $# -gt 1 && "$2" != 'default' ]] && context['divider']=$2
    [[ $# -gt 2 && "$3" != 'default' ]] && context['align']=$3
    [[ $# -gt 3 && "$4" != 'default' ]] && context['select.color']=$4
    [[ $# -gt 4 && "$5" != 'default' ]] && context['radio.button.symbol']=$5
    [[ $# -gt 5 && "$6" != 'default' ]] && context['check.button.symbol']=$6

    map[$1]=$(declare -p context)
    MENUEX['map']=$(declare -p map)
}

# -----------------------------------------------------------------------------
# Set the extra style of the menu (replace the default style)
#
# 1 [IN]      handle                     - a name/handle of the menu
# 2 [IN][OPT] separator.show             - {true/false} whether to print the menu's
#                                          separator (true by default)
# 3 [IN][OPT] separator.symbol           - separator symbol ('-' by default)
# 4 [IN][OPT] name.header                - menu's name header (' * ' by default)
# 5 [IN][OPT] name.footer                - menu's name footer (':' by default)
# 6 [IN][OPT] radio.button.bracket.start - radio.button opening symbol ('(' by default)
# 7 [IN][OPT] radio.button.bracket.end   - radio.button closing symbol (')' by default)
# 8 [IN][OPT] check.button.bracket.start - check.button opening symbol ('[' by default)
# 9 [IN][OPT] check.button.bracket.end   - check.button closing symbol (']' by default)
#
# Remark: 'default' can be used to specify the default argument
#
# -----------------------------------------------------------------------------
MENU.SetStyleEx() {
    if [[ $# -lt 1 ]]; then
      MENU._error 'MENU.SetStyle requires more arguments'
      return
    fi

    eval "${MENUEX['map']}"
    eval "${map["$1"]}"

    # By default
    context['separator.show']='true'
    context['separator.symbol']='-'
    context['name.header']=' * '
    context['name.footer']=':'
    context['radio.button.bracket.start']='('
    context['radio.button.bracket.end']=')'
    context['check.button.bracket.start']='['
    context['check.button.bracket.end']=']'

    # Optional arguments
    [[ $# -gt 1 && "$2" != 'default' ]] && context['separator.show']=$2
    [[ $# -gt 2 && "$3" != 'default' ]] && context['separator.symbol']=$3
    [[ $# -gt 3 && "$4" != 'default' ]] && context['name.header']=$4
    [[ $# -gt 4 && "$5" != 'default' ]] && context['name.footer']=$5
    [[ $# -gt 5 && "$6" != 'default' ]] && context['radio.button.bracket.start']=$6
    [[ $# -gt 6 && "$7" != 'default' ]] && context['radio.button.bracket.end']=$7
    [[ $# -gt 7 && "$8" != 'default' ]] && context['check.button.bracket.start']=$8
    [[ $# -gt 8 && "$9" != 'default' ]] && context['check.button.bracket.end']=$9

    map[$1]=$(declare -p context)
    MENUEX['map']=$(declare -p map)
}

# -----------------------------------------------------------------------------
# Add a child menu into the parent menu. Allows to create independently
# functioning radio buttons in the same menu
#
# [IN] parent - name of the main (parent) menu
# [IN] child  - a menu to serve as a sub (child) menu for the parent menu
#
# Remark: When a menu becomes a child menu it style changes automatically and
# it looses some of its properties, like 'name', 'header', 'footer', and the
# main menu's 'alias'
#
# -----------------------------------------------------------------------------
MENU.AddMenu() {
    if [[ $# -ne 2 ]]; then
        MENU._error "MENU.AddMenu requires more arguments"
        return
    fi

    eval "${MENUEX['map']}"

    eval "${map["$1"]}"
    if [[ "${context['is.sub.menu']}" == "true" ]]; then
        MENU._error "Nesting is not supported! 'parent' ['$1'] is a child menu itself."
        return
    fi

    eval "${map["$2"]}"
    if [ ${#context[@]} -eq 0 ]; then
        MENU._error "No sub menu '$2' has been found!"
        return
    fi

    context['is.sub.menu']=true
    context['parent.menu']=$1

    # Since menu $2 will be a sub menu it will not have those fields:
    # 'name', name's header and footer, and 'alias'
    context['name']='MENU.Null'
    context['name.header']=''
    context['name.footer']=''

    # If 'alias' was created then we have to delete it
    if [ "${context['alias']}" != '' ]; then
        if [ `alias | grep "alias ${context['alias']}=" | wc -l` != 0 ]; then
            unalias "${context['alias']}"
        fi
    fi

    context['alias']='MENU.Null'

    map[$2]=$(declare -p context)
    MENUEX['map']=$(declare -p map)

    eval "${map["$1"]}"
    if [ ${#context[@]} -eq 0 ]; then
        MENU._error "No main menu '$1' has been found!"
        return
    fi

    eval "${context['sub.menus']}"
    submenus["${#submenus[@]}"]=$2

    context['has.sub.menu']='true'
    context['sub.menus']=$(declare -p submenus)

    map[$1]=$(declare -p context)
    MENUEX['map']=$(declare -p map)
}

# -----------------------------------------------------------------------------
# [IN] type - the type of an item to be added, supported types:
#       {radio.button, check.button, divider, ln.break}
#
# [IN] $* - the rest of arguments comes from the public .Add function
#
# -----------------------------------------------------------------------------
MENU._add_item() {
    if [[ $# -lt 2 ]]; then
        MENU._error "MENU._add_item requires more arguments"
        return
    fi

    MENU._log_info "args: $*"

    eval item_name="$3"

    local -A item=()
    item['type']=$1
    item['name']=$item_name
    item['checked']='off' # used for 'check.button' items only
    item['alias']='MENU.Null'
    item['callback']='MENU.Null'

    # Optional arguments
    [ $# -gt 3 ] && item['alias']=$4
    [ $# -gt 4 ] && item['callback']=$5

    eval "${MENUEX['map']}"
    eval "${map["$2"]}"
    eval "${context['items']}"

    items[${#items[@]}]=$(declare -p item)
    context['items']=$(declare -p items)

    [ "${item['type']}" == 'ln.break' ] && context['is.ln.break.last']='true' || context['is.ln.break.last']='false'

    # Used for 'by.largest.item' alignment since we need to know what item's length is the longest one
    [[ ${context['item.length.max']} -lt ${#item['name']} ]] && context['item.length.max']=${#item['name']}

    map[$2]=$(declare -p context)
    MENUEX['map']=$(declare -p map)

    [[ "${item['type']}" != 'radio.button' && "${item['type']}" != 'check.button' ]] && return

    # Create an alias to call the menu's callback
    if [[ "${item['alias']}" != 'MENU.Null' ]] && [[ "${item['callback']}" != 'MENU.Null' ]]; then
        if [ `alias | grep "alias ${item['alias']}=" | wc -l` != 0 ]; then
            MENU._warning "Alias '${item['alias']}' already exists in the env and will not be reasigned!"
            [[ "${MENUEX['build']}" == 'Release' ]] && return
        fi

        [[ "${item['type']}" == 'radio.button' ]] && local f2='true' || local f2='false'
        alias "${item['alias']}"="MENU._select $2 \"${item['name']}\" $f2"
    fi
}

# -----------------------------------------------------------------------------
# Add a item into a menu
#
# [IN]      handle   - a handle of the menu
# [IN]      name     - a name of an item to be added into the menu
# [IN][OPT] alias    - an alias to be created that selects the item
# [IN][OPT] callback - a function to be called when the item is selected
#
# Remark: The 'alias' parameter creates the alias for the item unless the alias
#         already exists in the environment; If 'alias' is part of the name,
#         for example item item = 'MyItem1' alias = 'em1', then the alias 'em1'
#         will be hightlighted (underlined) when displayed.
#
# Remark: When the item's 'callback' is called there are 2 arguments passed
#         into the callbak: [IN] name - the menu name and [IN] item - the
#         selected item name;
#
# Remark: When 'callback' function is called it has 3 arguments passed in:
#
# [IN]      handle - the menu's name/handle
# [IN]      name   - the name of the selected item
# [IN][OPT] state  - {on, off} item's state (check.button type only)
#
# Example:
#
# > MENU.AddRadioButton MyMenu1 Item1 m1 Menu1Item1_Cb
# > MENU.AddRadioButton MyMenu1 Item2 m2 Menu1Item2_Cb
#
# -----------------------------------------------------------------------------
MENU.AddRadioButton() {
    # A trick to pass an item's name string as a variable to be able
    # to use spaces in the name string, e.g. "Menu Item 1"
    local menu_name=$1
    local item_name="$2"
    shift 2
    local cmd="MENU._add_item radio.button $menu_name \"\${item_name}\" $*"
    ${cmd}
}

MENU.AddCheckButton() {
    local menu_name=$1
    local item_name="$2"
    shift 2
    local cmd="MENU._add_item check.button $menu_name \"\${item_name}\" $*"
    ${cmd}
}

MENU.AddLnBreak() {
    local cmd="MENU._add_item ln.break $*"
    ${cmd}
}

MENU.AddLabel() {
    local menu_name=$1
    local item_name="$2"
    shift 2
    local cmd="MENU._add_item label $menu_name \"\${item_name}\" $*"
    ${cmd}
}

MENU.AddDivider() {
    local cmd="MENU._add_item divider $*"
    ${cmd}
}

# -----------------------------------------------------------------------------
# Selects an item in the menu
#
# [IN]      arg1  - name of the menu
# [IN]      arg2  - name of the item to be selected
#
# The rest of the arguments are 'false' by default:
#
# [IN][OPT] show  - {true/false} whether to call MENU.Show
# [IN][OPT] flag1 - {true/false} whether to call the main manu's callback
# [IN][OPT] flag2 - {true/false} whether to call the selected item's callback
# [IN][OPT] mode  - call-mode of all the check button item's callbacks
#
# DEMO: For example, the following command selects 'Release' radio.button in
#       the demo 'Build' menu, shows the 'Build' menu, and calls the 'Release'
#       radio.button's callbacks:
#
# > MENU.Select build_menu Release true false true fals
#
# -----------------------------------------------------------------------------
MENU.Select() {
    if [[ $# -lt 2 ]]; then
        MENU._error 'MENU.Select requires more arguments'
        return
    fi

    eval "${MENUEX['map']}"
    eval "${map["$1"]}"

    MENU._log_info "ARGS: $*"
    [[ $# -gt 2 ]] && local show=$3 || local show='false'

    # current_item is used for a child menu trick to call only one callback of
    # the selected radio/check button and do not to call all the callbacks of
    # all the radio/check buttons of all child menus
    current_item="$2"

    # We have to go through items[] first to check whether
    # the selected item is a check button type item
    eval "${context['items']}"
    local check_button_set
    for i in "${!items[@]}"; do
        eval "${items["$i"]}"
        if [[ "${item['name']}" == $2 ]] && [[ "${item['type']}" == 'check.button' ]]; then
            [[ "${item['checked']}" == 'on' ]] && item['checked']='off' || item['checked']='on'
            items["$i"]=$(declare -p item)
            context['items']=$(declare -p items)
            MENU._log_info "CHECK BOX: '$current_item' state='${item['checked']}'"
            check_button_set='true'
            break
        fi
    done

    # Set selected if the itme's type is the radio.button
    if [[ ! "$check_button_set" ]]; then
        context['selected']=$2
    fi

    map[$1]=$(declare -p context)
    MENUEX['map']=$(declare -p map)

    [[ $# -gt 3 ]] && flag1=$4 || flag1='false'
    [[ $# -gt 4 ]] && flag2=$5 || flag2='false'
    [[ $# -gt 5 ]] && mode=$6 || mode='false'

    # When called from an alias of an item there is an optional extra argument
    # true/false whether to call the main menu's callback in addition
    [[ $# -gt 6 ]] && flag1=$7

    if [ "$show" == 'true' ]; then
        MENU._log_info "Show $1 f1=$flag1 f2=$flag2 mode=$mode"
        MENU.Show $1 $flag1 $flag2 $mode
    fi

    unset current_item
}

# arguments are comming from the item's alias: $*
MENU._select() {
    MENU._log_info "ARGS: $*"

    [[ $# -gt 2 ]] && local f2=$3 || local f2='false'

    # an extra {true/false} might come from an alias argument
    # to call the main menu's callback
    [[ $# -gt 3 ]] && local f1=$4 || local f1='false'

    MENU.Select $1 "$2"

    MENU._separator $1
    MENU.Show $1 $f1 $f2 current
    MENU._separator $1

    unset current_item
}

# -----------------------------------------------------------------------------
# Performs an operation for all the check.button items in the menu
#
# [IN] name - a name/handle of the menu
# [IN] operation - a type of operation to perform on all the check.buttons:
#       check   - check all the check.button items
#       uncheck - un-check all the check.button itmes
#       flip    - flip the state of all the check.button itmes
#
# The rest of the arguments are 'false' by default:
#
# [IN][OPT] show  - {true/false} whether to call MENU.Show
# [IN][OPT] flag1 - {true/false} whether to call the main manu's callback
# [IN][OPT] flag2 - {true/false} whether to call the selected item's callback
# [IN][OPT] mode  - call-mode of all the check.button item's callbacks
#
# DEMO: For example, the following command flips all the check.buttons in the
#       demo 'Build' menu, shows the 'Build' menu, and calls all the checked
#       check.button's callbacks:
#
# > MENU.CheckButtonForAll build_menu flip true false false checked
#
# -----------------------------------------------------------------------------
MENU.CheckButtonForAll() {
    if [ $# -lt 2 ]; then
        MENU._error "MENU.CheckButtonForAll requires more arguments"
        return
    fi

    MENU._log_info "ARGS: $*"

    eval "${MENUEX['map']}"
    eval "${map["$1"]}"
    eval "${context['items']}"

    local changed='false'
    for i in "${!items[@]}"; do
        eval "${items["$i"]}"

        [ "${item['type']}" != 'check.button' ] && continue;

        local updated='false'
        case $2 in
            check)
                [ "${item["checked"]}" == 'off' ] && item['checked']='on'; updated='true'
                ;;
            uncheck)
                [ "${item["checked"]}" == 'on' ] && item['checked']='off'; updated='true'
                ;;
            flip)
                [ "${item["checked"]}" == 'on' ] && item['checked']='off' || item['checked']='on'
                updated='true'
                ;;
        esac
        [ "$updated" == 'true' ] && items["$i"]=$(declare -p item); context['items']=$(declare -p items); changed='true'
    done

    if [[ "$changed" == 'true' ]]; then
        map[$1]=$(declare -p context)
        MENUEX['map']=$(declare -p map)
    fi

    [[ $# -gt 2 ]] && show=$3 || show='false'
    [[ $# -gt 3 ]] && flag1=$4 || flag1='false'
    [[ $# -gt 4 ]] && flag2=$5 || flag1='false'
    [[ $# -gt 5 ]] && mode=$6 || mode='false'

    if [ "$show" == 'true' ]; then
        MENU.Show $1 $flag1 $flag2 $mode
    fi
}

# -----------------------------------------------------------------------------
# Displays the menu
#
# [IN] name - a name/handle of the menu
#
# The rest of the arguments are 'false' by default:
#
# [IN][OPT] flag1 - {true/false} whether to call the main manu's callback
# [IN][OPT] flag2 - {true/false} whether to call the selected item's callback
# [IN][OPT] mode  - call-mode of all the check button item's callbacks:
#            no (false)   - do not call any callback for any item
#            all (true)   - call all the callbacks for all check.button items
#                           regardless of its state
#            current      - call the callback of the check.button items that
#                           changes the state (.Select command only)
#            checked      - call all the callbacks for all checked check.buttons
#            unchecked    - call all the callbacks for all un-checked
#                           check.buttons
#
# DEMO: For example, the following command simply shows/displays the demo
#       'PLATFORM' menu w/o calling any callbacks:
#
# > MENU.Show pl_menu false false false
#
# -----------------------------------------------------------------------------
MENU.Show() {
    if [ $# -lt 1 ]; then
        MENU._error 'MENU.Show requires more arguments'
        return
    fi

    MENU._log_info "ARGS: $*"

    eval "${MENUEX['map']}"
    eval "${MENUEX['styles']}"
    eval "${map["$1"]}"

    if [ "${context['is.sub.menu']}" == 'true' ]; then
        local parent=${context['parent.menu']}
        MENU._log_warning "'$1' is a sub menu. Show the parent '$parent' menu instead"
        eval "${map["$parent"]}"
    fi

    local -a callbacks=()
    local -a arguments=()
    local idx=0

    # Is used to 'space'-pad the menu after line break
    local parent_header_pad=''
    if [ "${context['name']}" != 'MENU.Null' ]; then
        local width=${#context['name']}
        ((width += ${#context['name.header']}))
        ((width += ${#context['name.footer']}))
        ((width += 1))
        parent_header_pad=$(MENU._string_pad '' $width)
    fi

    eval "${context['sub.menus']}"
    local parent_sub_menus=("${submenus[@]}")
    local sub_menu_count=$((${#submenus[@]}))
    local is_parent_ln_break=${context['is.ln.break.last']}
    local sub_menu_index=0

    local has_sub_menu='false'
    if [ "${context['has.sub.menu']}" == "true" ] && [ $sub_menu_count -gt 0 ]; then
        has_sub_menu='true'
    fi

    while true; do
        eval "${context['items']}"

        if [ "${context['name']}" != 'MENU.Null' ]; then
            printf "${context['name.header']}${context['name']/${context['alias']}/${styles['smul']}${context['alias']}${styles['reset']}}${context['name.footer']} "
        fi

        # Store the main menu's callback to be called later
        if [ "$2" == 'true' ] && [ "${context['callback']}" != 'MENU.Null' ]; then
            callbacks[$idx]=${context['callback']}
            [[ "${context['name']}" != 'MENU.Null' ]] && arguments[$idx]+="$1 ${context['name']}" || arguments[$idx]="$1"
            ((idx++))
        fi

        # The number of spaces needed to cover the radio/check.button symbol for example: [' '] one space
        # if symbol 'x' is 1 char, and 3 spaces ['   '] if button symbol is 'xxx' 3 chars
        local check_spaces=$(MENU._string_pad '' ${#context['check.button.symbol']})
        local radio_spaces=$(MENU._string_pad '' ${#context['radio.button.symbol']})

        if [ "$show_alias" == 'true' ]; then
            printf '\n'
        fi

        for i in "${!items[@]}"; do
            eval "${items["$i"]}"

            local name=${item['name']}
            if [ "$show_alias" == 'true' ]; then
                if [ "${item['alias']}" != 'MENU.Null' ]; then
                    name+=" - '${item['alias']}'"
                fi
                printf "   > $name\n"
                continue
            fi

            if [ "${context['align']}" == 'by.largest.item' ] && [ "${item['type']}" != 'label' ]; then
                local sz=${context['item.length.max']}
                ((sz -= ${#name}))
                local pad=$(MENU._string_pad '' $sz)
                name=${name}$pad
            fi

            local type=${item['type']}
            if [ "$type" == 'ln.break' ]; then
                printf '\n'
                if [ "${context['name']}" != 'MENU.Null' ] || [ "${context['is.sub.menu']}" == 'true' ]; then
                    printf "$parent_header_pad"
                fi
                continue
            fi

            if [ "$type" == 'divider' ]; then
                local divider=${context['divider']}
                printf "$divider "
                continue;
            fi

            if [ "$type" == 'label' ]; then
                printf "$name "
                continue;
            fi

            local alias=${item['alias']}
            local color_ref=${context['select.color']}
            local color=${styles["$color_ref"]}
            local selected=${context['selected']}

            if [ "$type" == 'radio.button' ]; then
                if [ "${item['name']}" == "$selected" ]; then
                    local hi=${styles['smul']}${item['alias']}${styles['rmul']}

                    # '(*) Name '
                    printf "${color}${styles['bold']}${context['radio.button.bracket.start']}"
                    printf "${context['radio.button.symbol']}${context['radio.button.bracket.end']} "
                    printf "${name/$alias/$hi}${styles['reset']} "

                    # Store the radio button item's callback to be called later
                    if [ "$3" == 'true' ] && [ "${item['callback']}" != 'MENU.Null' ]; then
                        if [ ! $current_item ] || [ "$current_item" == "${item['name']}" ]; then
                            callbacks[$idx]=${item['callback']}
                            arguments[$idx]="$1 ${item['name']}"
                            ((idx++))
                        fi
                    fi
                else
                    # '( ) Name '
                    printf "${context['radio.button.bracket.start']}$radio_spaces${context['radio.button.bracket.end']} "
                    printf "${name/$alias/${styles['smul']}$alias${styles['reset']}} "
                fi
                continue;
            fi

            if [ "$type" == 'check.button' ]; then
                local mode=$4
                if [ "${item['checked']}" == 'on' ]; then
                    local hi=${styles['smul']}${item['alias']}${styles['rmul']}

                    # '[x] Name '
                    printf "${color}${styles['bold']}${context['check.button.bracket.start']}${context['check.button.symbol']}"
                    printf "${context['check.button.bracket.end']} ${name/$alias/$hi}${styles['reset']} "

                    if [ "$mode" == 'checked' ] && [ "${context['callback']}" != 'MENU.Null' ]; then
                        callbacks[$idx]=${item['callback']}
                        arguments[$idx]="$1 ${item['name']} ${item['checked']}"
                        ((idx++))
                    fi
                else
                    # '[ ] Name '
                    printf "${context['check.button.bracket.start']}$check_spaces${context['check.button.bracket.end']} "
                    printf "${name/$alias/${styles['smul']}$alias${styles['reset']}} "

                    if [ "$mode" == 'unchecked' ] && [ "${context['callback']}" != 'MENU.Null' ]; then
                        callbacks[$idx]=${item['callback']}
                        arguments[$idx]="$1 ${item['name']} ${item['checked']}"
                        ((idx++))
                    fi
                fi

                if [ "$current_item" == "${item['name']}" ] && [ "$mode" == 'current' ] && [ "${context['callback']}" != 'MENU.Null' ]; then
                    callbacks[$idx]=${item['callback']}
                    arguments[$idx]="$1 ${item['name']} ${item['checked']}"
                    ((idx++))

                    MENU._log_ln
                    MENU._log_warning "mode: $mode current_item: $current_item"
                    MENU._log_warning "${item['callback']} ${item['name']} ${item['checked']}"
                fi

                # Store all the check button item's callbacks to be called later
                if [ "$mode" == 'all' ] || [ "$mode" == 'true' ] && [ "${context['callback']}" != 'MENU.Null' ]; then
                    callbacks[$idx]=${item['callback']}
                    arguments[$idx]="$1 ${item['name']} ${item['checked']}"
                    ((idx++))
                fi

                continue;
            fi
        done

        # if parent has sub-menus then unpack sub menu each by each and print it all
        if [ "$has_sub_menu" == 'true' ]; then
            if [[ $sub_menu_count -gt $sub_menu_index ]]; then
                if [ "$is_parent_ln_break" == 'true' ] && [ $sub_menu_index -gt 0 ]; then
                    printf "\n$parent_header_pad"
                fi
                local subname=${parent_sub_menus["$sub_menu_index"]}
                eval "${map["$subname"]}"
                ((sub_menu_index++))
                continue
            fi
        fi

        break
    done

    printf '\n'

    # Last, call all the callbacks with its arguments that needs to be called
    for i in "${!callbacks[@]}"; do
        cb=${callbacks[$i]}
        [[ "${arguments[$i]}" ]] && cb+=" ${arguments[$i]}"
        ${cb}
    done
}

# -----------------------------------------------------------------------------
# Displays all the menus created
#
# All the optional arguments are 'false' by default:
#
# [IN][OPT] order - {true/false} whether to display all the menus in the order
#           of how the menus were created
# [IN][OPT] flag1 - {true/false} whether to call the main manu's callback
# [IN][OPT] flag2 - {true/false} whether to call the selected item's callback
# [IN][OPT] mode  - call-mode of all the check.button item's callbacks
#
# Remark: By default, the displaying order of the menus corresponds to the
#         order of how the keys of the bash's assosiative array are sorted
#
# -----------------------------------------------------------------------------
MENU.ShowAll() {
    [[ $# -gt 0 ]] && order=$1 || order='false'
    [[ $# -gt 1 ]] && f1=$2 || f1='false'
    [[ $# -gt 2 ]] && f2=$3 || f2='false'
    [[ $# -gt 3 ]] && mode=$4 || mode='false'

    local last_menu=''
    if [ "$order" == 'true' ]; then
        eval "${MENUEX['order']}"
        for i in "${!order[@]}"; do
            last_menu=${order[$i]}

            eval "${MENUEX['map']}"
            eval "${map["$last_menu"]}"
            [ "${context['is.sub.menu']}" == 'true' ] && continue

            MENU._separator $last_menu true
            MENU.Show $last_menu $f1 $f2 $mode
        done
    else
        eval "${MENUEX['map']}"
        for menu in "${!map[@]}"; do
            eval "${map["$menu"]}"

            [ "${context['is.sub.menu']}" == 'true' ] && continue

            last_menu=$menu
            MENU._separator $menu true
            MENU.Show $menu $f1 $f2 $mode
        done
    fi

    MENU._separator $last_menu true
}

# -----------------------------------------------------------------------------
# The lenght of the separator needs to be dynamically calculated because of such
# factors as ln.break, alignment, and customizable chars for the radio/check
# buttons
#
# [IN]  name   - the menu's handle
# [OUT] length - the length of the menu
#
# -----------------------------------------------------------------------------
MENU._calculate_menu_width() {
    if [ $# -lt 1 ]; then
        MENU._error 'MENU._calculate_menu_width requires more arguments'
        return
    fi

    eval "${MENUEX['map']}"
    eval "${map["$1"]}"
    eval "${context['items']}"

    local max=0
    local length=0

    for i in "${!items[@]}"; do
        eval "${items["$i"]}"

        local item_length=0
        case ${item['type']} in
            check.button | radio.button)
                [ "${context['align']}" == "by.largest.item" ] && ((item_length += ${context['item.length.max']})) || ((item_length += ${#item['name']}))
                ((item_length += ${#context["${item['type']}.bracket.start"]}))
                ((item_length += ${#context["${item['type']}.bracket.end"]}))
                ((item_length += ${#context["${item['type']}.symbol"]}))
                ((item_length += 1))
                ;;
            divider)
                ((item_length += ${#context['divider']}))
                ;;
            label)
                ((item_length += ${#item['name']}))
                ;;
            ln.break)
                [ $length -gt $max ] && max=$length
                length=0
                continue
                ;;
        esac

        ((item_length += 1)) # one space ' ' after each item's name
        ((length += $item_length))
    done

    [ $length -gt $max ] && max=$length

    local width=0
    [ $max -gt 0 ] && width=$max || width=$length

    #
    # A special corner case of [main.menu][ln.break] + [sub.menu] needs some
    # special handling because the [sub.menu] length now needs to add the length
    # of 'parent.menu' header and now the max length of the menu needs to take
    # it into account that [sub.menu] length might become the biggest length of
    # the entire menu; 'context' has 2 flags to mark this very corner case:
    # 'is.ln.break.last' and 'has.sub.menu'
    if [ "${context['is.sub.menu']}" == 'true' ]; then
        local parent="${context['parent.menu']}"
        eval "${map["$parent"]}"
        if [ "${context['is.ln.break.last']}" == 'false' ]; then
            echo $width
            return
        fi
    fi

    # When we get here the context is either the menu or the parent menu
    if [[ "${context['name']}" != 'MENU.Null' ]]; then
        ((width += ${#context['name']}))
        ((width += ${#context['name.header']}))
        ((width += ${#context['name.footer']}))
        ((width += 1)) # one space ' ' after the menu's name
    fi

    echo $width
}

# -----------------------------------------------------------------------------
# Prints out the menus' separator
#
# [IN]      menu    - the menu's handle
# [IN][OPT] largest - {true/false} whether to use the largest length
#                     of all the menus
#
# -----------------------------------------------------------------------------
MENU._separator() {
    if [ $# -lt 1 ]; then
        MENU._error 'MENU._separator requires more arguments'
        return
    fi

    local width=0

    # One time procedure; The widths of the menu have never been calculated;
    # Iterate through all the menus and calculate the width for each of the menus
    if [ ${MENUEX['width.max']} -lt 1 ]; then
        eval "${MENUEX['map']}"
        for menu in "${!map[@]}"; do
            width=$(MENU._calculate_menu_width $menu)
            [[ $width -gt ${MENUEX['width.max']} ]] && MENUEX['width.max']=$width

            MENU._log_warning "Re-calc: $menu[menu.width]: $width"

            eval "${map["$menu"]}"

            context['menu.width']=$width
            map[$menu]=$(declare -p context)
            MENUEX['map']=$(declare -p map)
        done

        # now let's take care of sub menus
        eval "${MENUEX['map']}"
        for menu in "${!map[@]}"; do
            eval "${map["$menu"]}"
            [ "${context['is.sub.menu']}" == 'true' ] && continue

            eval "${context['sub.menus']}"
            [ ${#submenus[@]} -eq 0 ] && continue

            local parent_ln_break=${context['is.ln.break.last']}
            width=${context['menu.width']}
            for i in ${!submenus[@]}; do
                local subname=${submenus["$i"]}
                eval "${map[$subname]}"
                MENU._log_warning "submenus[$i]: $subname['menu.width']: ${context['menu.width']}"
                if [ "$parent_ln_break" == 'true' ]; then
                    [ ${context['menu.width']} -gt $width ] && width=${context['menu.width']}
                else
                    ((width += ${context['menu.width']}))
                fi
            done

            MENU._log_warning "Re-calc w/ subs: $menu[menu.width]: $width"
            [[ $width -gt ${MENUEX['width.max']} ]] && MENUEX['width.max']=$width

            # Update the new width w/ all the subs combined
            eval "${map["$menu"]}"

            context['menu.width']=$width
            map[$menu]=$(declare -p context)
            MENUEX['map']=$(declare -p map)
        done
    fi

    eval "${MENUEX['map']}"
    eval "${map["$1"]}"

    # if it's a sub menu then we have to use the parent's menu width
    if [ "${context['is.sub.menu']}" == 'true' ]; then
        menu=${context['parent.menu']}
        eval "${map["$menu"]}"
    fi

    width=${context['menu.width']}

    [[ $# -gt 1 && "$2" == 'true' ]] && width=${MENUEX['width.max']}

    if [ "${context['separator.show']}" == 'true' ]; then
        ((width--)) # compensation for the way printf works
        cmd="printf -- '${context['separator.symbol']}%.0s' {1..$width}"
        eval $cmd
        echo ""
    fi
}

# arguments are comming from the main menu's alias: $* f1 f2 mode
MENU._show() {
    [[ $# -gt 4 ]] && f1=$5 || f1='false'
    [[ $# -gt 5 ]] && f2=$6 || f2='false'
    [[ $# -gt 6 ]] && mode=$7 || mode='false'

    if [[ $# -gt 4 ]] && [[ "$5" == '-h' ]]; then
        show_alias='true'
    fi

    MENU._separator $1
    MENU.Show $1 $f1 $f2 $mode
    MENU._separator $1

    unset show_alias
}

MENU._debug_print() {
    eval "${map["$1"]}"
    eval "${MENUEX['styles']}"

    echo "* $1:"
    for ctx_key in "${!context[@]}"; do
        if [ "$ctx_key" == 'items' ]; then
            echo "  - [$ctx_key]:"
            eval "${context["$ctx_key"]}"
            for items_key in "${!items[@]}"; do
                echo "    + [$items_key]: ${items["$items_key"]}"
                eval "${items["$items_key"]}"
                for indx in "${!item[@]}"; do
                    printf "      ♦ [$indx]: ${item["$indx"]}\n"
                done
            done
        else
            printf "  - [$ctx_key]: ${context["$ctx_key"]}${styles['reset']}\n"
        fi
    done
}

MENU._debug_print_all() {
    [[ "${MENUEX['build']}" == 'Release' ]] && return

    eval "${MENUEX['map']}"
    for key in "${!map[@]}"; do
        MENU._debug_print $key
    done
}

# -----------------------------------------------------------------------------
