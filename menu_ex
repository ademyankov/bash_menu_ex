#!/bin/sh

# -----------------------------------------------------------------------------
# Customizable console menu to organize different environment settings
#
# Alex Demyankov
# alex.demyankov@gmail.com
# https://www.linkedin.com/in/ademyankov/
#
# March, 2020
#
# -----------------------------------------------------------------------------

# Global Map that holds all the menus created
unset MENUEX
declare -A MENUEX=()
MENUEX["map"]="declare -A map=()"
MENUEX["order"]="declare -a order=()"
MENUEX["width"]=0
MENUEX["build"]='Debug'

# Tracks the order of menus created

# Change to 'Debug' if logs are needed
unset MENUBUILD
#declare -g MENUBUILD='Release'
declare -g MENUBUILD='Debug'

# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# All kinds of cool stuff for environment
#
# Num  Colour    define          R G B
# 0    black     COLOR_BLACK     0,0,0
# 1    red       COLOR_RED       1,0,0
# 2    green     COLOR_GREEN     0,1,0
# 3    yellow    COLOR_YELLOW    1,1,0
# 4    blue      COLOR_BLUE      0,0,1
# 5    magenta   COLOR_MAGENTA   1,0,1
# 6    cyan      COLOR_CYAN      0,1,1
# 7    white     COLOR_WHITE     1,1,1
#
# -----------------------------------------------------------------------------
black=`tput setaf 0`
red=`tput setaf 1`
green=`tput setaf 2`
yellow=`tput setaf 3`
blue=`tput setaf 4`
magenta=`tput setaf 5`
cyan=`tput setaf 6`
white=`tput setaf 7`

reset=`tput sgr0`

bold=`tput bold`  # Select bold mode
dim=`tput dim`    # Select dim (half-bright) mode
smul=`tput smul`  # Enable underline mode
rmul=`tput rmul`  # Disable underline mode
smso=`tput smso`  # Enter standout (bold) mode
rmso=`tput rmso`  # Exit standout mode
rev=`tput rev`    # Turn on reverse video mode

# -----------------------------------------------------------------------------
#
# Functions and parameters acronims
#
# [IN]  - input argument
# [OPT] - optional argument
# [OUT] - output result
#
# MENU.Null - is a special string that represents 'no string' for an optional
#             string argument; it can be usefull when an optional string
#             argument is in the middle of the arguments list, For example:
#             "MENU.Create menu1 MENU.Null MENU.Null Menu1Function". In case of
#             "MENU.Create menu1 '' '' Menu1Function" it would be impossible to
#             separate one parameter from the others inside the function
#
# MENU._lover_case - functions, named in such a way, are private and are not
#                    supposed to be called directly, but nothing prevents it
#
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# Pads a string with 'space' chars to the length specified
#
# [IN] string - a string to pad
# [IN] length - the length the output string should be
# [OUT] returns the padded string
#
# -----------------------------------------------------------------------------
MENU._string_pad() {
    local len=$(($2 - ${#1}))
    pad=`printf '%*s' "$len" | tr ' ' " "`
    echo "$1$pad"
}

# -----------------------------------------------------------------------------
# Converts a string to an upper case string
#
# [IN] string - a string to convert
# [OUT] returns the converted string
#
# -----------------------------------------------------------------------------
MENU._to_upper() {
    echo "$(echo ${1} | awk '{print toupper($0)}')"
}

# -----------------------------------------------------------------------------
# Helper functions to display log/trace
#
# [IN] string - a log's mode, supported: {INFO, WARNING, SEVERE}
#
# -----------------------------------------------------------------------------
MENU._log() {
    local marker="${green}${bold}INFO${reset}:"
    [[ "$1" == "WARNING" ]] && marker="${yellow}${bold}WARNING${reset}:"
    [[ "$1" == "SEVERE" ]] && marker="${red}${bold}SEVERE${reset}:"
    shift
    echo "${FUNCNAME[2]}: $marker $*"
}

MENU._log_info() {
    [[ "$MENUBUILD" == "Debug" ]] && MENU._log INFO $1
}

MENU._log_warning() {
    [[ "$MENUBUILD" == "Debug" ]] && MENU._log WARNING $1
}

MENU._error() {
  MENU._log SEVERE $1
}

MENU._warning() {
  MENU._log WARNING $1
}

# -----------------------------------------------------------------------------
# Creates a new menu
#
# [IN]      handle   - a name/handle of the menu to be used w/ the API
# [IN][OPT] name     - a displayed name of the menu
# [IN][OPT] alias    - an alias to be created that displays the menu
# [IN][OPT] callback - a function to be called when the menu is displayed
#
# Remark: The 'alias' parameter creates the alias for the menu unless the alias
#         already exists in the environment
#
# When 'callback' function is called it has 2 arguments passed in:
#
# [IN] handle - the menu's name/handle
# [IN] name   - the menu's name (if specified)
#
# -----------------------------------------------------------------------------
MENU.Create() {
    if [[ $# -lt 1 ]]; then
        MENU._error "MENU.Create requires more arguments"
        return
    fi

    local -A context=()
    context["name"]='MENU.Null'
    context["alias"]='MENU.Null'
    context["callback"]='MENU.Null'
    context["checked"]=''
    context["selected"]=''
    context["item.length.max"]=0   # the max char length of an item's name
    context["menu.width"]=0     # the length of the longest string in the menu (used for menu's separator)

    MENU._log_info "args: $*"

    context["name"]=$2
    if [ "$2" != "MENU.Null" ]; then
        context["menu.width"]=${#2}
        ((context["menu.width"] += 5 )) # ' * ' + <name> + ': '
    fi

    [ $# -gt 2 ] && context["alias"]=$3
    [ $# -gt 3 ] && context["callback"]=$4

    local -a items=()
    context["items"]=$(declare -p items)

    eval "${MENUEX["map"]}"
    map[$1]=$(declare -p context)
    MENUEX["map"]=$(declare -p map)

    eval "${MENUEX["order"]}"
    order[${#order[@]}]=$1
    MENUEX["order"]=$(declare -p order)

    local default="MENU.SetStyle $1"
    ${default}

    default="MENU.SetStyleEx $1"
    ${default}

    # Create an alias to display the menu
    if [ "${context['alias']}" != '' ]; then
        if [ `alias | grep ${context['alias']} | wc -l` != 0 ]; then
            MENU._warning "Alias '${context['alias']}' already exists in the env and will not be reasigned!"
            [ "$MENUBUILD" == "Release" ] && return
        fi
        local argc="$1 ${context["name"]} ${context["alias"]} ${context["callback"]}"
        alias "${context['alias']}"="MENU._show ${argc}"
    fi
}

# -----------------------------------------------------------------------------
# Sets the style for the menu
#
# [IN]      handle  - a name/handle of the menu to be used w/ the API
# [IN][OPT] divider - a divider to be used w/ .AddDivider ('|' by default)
#
# [IN][OPT] align   - the menu's items alignment (none by default), supported:
#             by.largest.item - aligns all the menu's items by the length of the
#                               largest item's name
#
# [IN][OPT] color        - the color of the selected item (green by default)
# [IN][OPT] radio.symbol - the symbol for the selected radio-button ('♦' by default)
# [IN][OPT] radio.symbol - the symbol for the cheched check-button ('x' by default)
#
# Remark: 'default' can be passed as any [OPT] argument, which will set the
#         default value for the corresponding style parameter
#
# Example:
#
# > MENU.SetStyle menu1 default default ${red} '○' default
#
# -----------------------------------------------------------------------------
MENU.SetStyle() {
    if [[ $# -lt 1 ]]; then
      MENU._error "MENU.SetStyle requires more arguments"
      return
    fi

    eval "${MENUEX["map"]}"
    eval "${map["$1"]}"

    # By default
    context["divider"]='|'
    context["align"]='none'
    context["color"]=${green}
    context["radio.symbol"]='♦'
    context["check.symbol"]='x'

    # Optional arguments
    [[ $# -gt 1 && "$2" != "default" ]] && context["divider"]=$2
    [[ $# -gt 2 && "$3" != "default" ]] && context["align"]=$3
    [[ $# -gt 3 && "$4" != "default" ]] && context["color"]=$4
    [[ $# -gt 4 && "$5" != "default" ]] && context["radio.symbol"]=$5
    [[ $# -gt 5 && "$6" != "default" ]] && context["check.symbol"]=$6

    # In case of a complex alignment the menu's width needs to be calculated when shown
    [[ "${context["align"]}" == "by.largest.item" ]] && context["menu.width"]=0

    map[$1]=$(declare -p context)
    MENUEX["map"]=$(declare -p map)
}

# -----------------------------------------------------------------------------
# Set the extra style of the menu (replace the default style)
#
# 1 [IN]      handle             - a name/handle of the menu to be used w/ the API
# 2 [IN][OPT] separator.show     - xxx
# 3 [IN][OPT] separator.symbol   -
# 4 [IN][OPT] name.header        -
# 5 [IN][OPT] name.footer        -
# 6 [IN][OPT] radio.symbol.start -
# 7 [IN][OPT] radio.symbol.end   -
# 8 [IN][OPT] check.symbol.start -
# 9 [IN][OPT] check.symbol.end   -
#
# Remark: 'default' can be used to specify the default argument
#
# -----------------------------------------------------------------------------
MENU.SetStyleEx() {
    if [[ $# -lt 1 ]]; then
      MENU._error "MENU.SetStyle requires more arguments"
      return
    fi

    eval "${MENUEX["map"]}"
    eval "${map["$1"]}"

    # By default
    context["separator.show"]='true'
    context["separator.symbol"]='-'
    context["name.header"]=' * '
    context["name.footer"]=':'
    context["radio.symbol.start"]='('
    context["radio.symbol.end"]=')'
    context["check.symbol.start"]='['
    context["check.symbol.end"]=']'

    # Optional arguments
    [[ $# -gt 1 && "$2" != "default" ]] && context["separator.show"]=$2
    [[ $# -gt 2 && "$3" != "default" ]] && context["separator.symbol"]=$3
    [[ $# -gt 3 && "$4" != "default" ]] && context["name.header"]=$4
    [[ $# -gt 4 && "$5" != "default" ]] && context["name.footer"]=$5
    [[ $# -gt 5 && "$6" != "default" ]] && context["radio.symbol.start"]=$6
    [[ $# -gt 6 && "$7" != "default" ]] && context["radio.symbol.end"]=$7
    [[ $# -gt 7 && "$8" != "default" ]] && context["check.symbol.start"]=$8
    [[ $# -gt 8 && "$9" != "default" ]] && context["check.symbol.end"]=$9

    map[$1]=$(declare -p context)
    MENUEX["map"]=$(declare -p map)
}

# -----------------------------------------------------------------------------
# [IN] type - the type of an item to be added, supported types:
#       {radio-button, check-button, divider, ln-break}
#
# [IN] $* - the rest of arguments comes from the public .Add function
#
# -----------------------------------------------------------------------------
MENU._add_item() {
    if [[ $# -lt 2 ]]; then
        MENU._error "MENU.AddItem requires more arguments"
        return
    fi

    MENU._log_info "args: $*"

    eval item_name="$3"

    local -A item=()
    item["type"]=$1
    item["name"]=$item_name
    item["checked"]='off' # used for 'check-button' items only
    item["alias"]='MENU.Null'
    item["callback"]='MENU.Null'

    # Optional arguments
    [ $# -gt 3 ] && item["alias"]=$4
    [ $# -gt 4 ] && item["callback"]=$5

    eval "${MENUEX["map"]}"
    eval "${map["$2"]}"
    eval "${context["items"]}"

    items[${#items[@]}]=$(declare -p item)
    context["items"]=$(declare -p items)

    # Used for 'by-largest' alignment since we need to know what item's length is the longest one
    [[ ${context["item.length.max"]} -lt ${#item["name"]} ]] && context["item.length.max"]=${#item["name"]}

    # Calculate the width of the menu only if it's a simple alignment mode;
    # because in case of 'by-largest' alignment we cannot accuratelly calculate
    # the width until all the items have been added into the menu
    if [ "${context["align"]}" != "by.largest.item" ]; then
        local item_width=${#item["name"]}
        ((item_width+=1)) # ' ' after each item's name
        [[ "${item['type']}" == "check-button" || "${item['type']}" == "radio-button" ]] && ((item_width+=4)) # '[ ] '
        ((context["menu.width"]+=$item_width))
    else
        # Will trigger to re-calculate again the menu's width in case an item is added
        # after the 'menu.width' was calculated the first time
        context["menu.width"]=0
    fi

    [[ ${context["menu.width"]} -gt ${MENUEX["width"]} ]] && MENUEX["width"]=${context["menu.width"]}

    map[$2]=$(declare -p context)
    MENUEX["map"]=$(declare -p map)

    [[ "${item['type']}" != "radio-button" && "${item['type']}" != "check-button" ]] && return

    # Create an alias to call the menu's callback
    if [[ "${item['alias']}" != '' ]] && [[ "${item['callback']}" != '' ]]; then
        if [ `alias | grep ${item['alias']} | wc -l` != 0 ]; then
            MENU._warning "Alias '${item['alias']}' already exists in the env and will not be reasigned!"
            [[ "$MENUBUILD" == "Release" ]] && return
        fi

        # See Select command for the flags:                       show   1    2   mode
        [[ "${item['type']}" == "radio-button" ]] && local flags="true false true false" || local flags="true false false current"
        alias "${item['alias']}"="MENU._select $2 \"${item["name"]}\" $flags"
    fi
}

# -----------------------------------------------------------------------------
# Add a item into a menu
#
# [IN]      handle   - a handle of the menu
# [IN]      name     - a name of an item to be added into the menu
# [IN][OPT] alias    - an alias to be created that selects the item
# [IN][OPT] callback - a function to be called when the item is selected
#
# Remark: The 'alias' parameter creates the alias for the item unless the alias
#         already exists in the environment; If 'alias' is part of the name,
#         for example item item = 'MyItem1' alias = 'em1', then the alias 'em1'
#         will be hightlighted (underlined) when displayed.
#
# Remark: When the item's 'callback' is called there are 2 arguments passed
#         into the callbak: [IN] name - the menu name and [IN] item - the
#         selected item name;
#
# Remark: When 'callback' function is called it has 3 arguments passed in:
#
# [IN]      handle - the menu's name/handle
# [IN]      name   - the name of the selected item
# [IN][OPT] state  - {on, off} item's state (check-button type only)
#
# Example:
#
# > MENU.AddRadioButton MyMenu1 Item1 m1 Menu1Item1_Cb
# > MENU.AddRadioButton MyMenu1 Item2 m2 Menu1Item2_Cb
#
# -----------------------------------------------------------------------------
MENU.AddRadioButton() {
    # A trick to pass an item's name string as a variable to be able
    # to use spaces in the name string, e.g. "Menu Item 1"
    local menu_name=$1
    local item_name="$2"
    shift 2
    local cmd="MENU._add_item radio-button $menu_name \"\${item_name}\" $*"
    ${cmd}
}

MENU.AddCheckButton() {
    local menu_name=$1
    local item_name="$2"
    shift 2
    local cmd="MENU._add_item check-button $menu_name \"\${item_name}\" $*"
    ${cmd}
}

MENU.AddLnBreak() {
    local cmd="MENU._add_item ln-break $*"
    ${cmd}
}

MENU.AddLabel() {
    local menu_name=$1
    local item_name="$2"
    shift 2
    local cmd="MENU._add_item label $menu_name \"\${item_name}\" $*"
    ${cmd}
}

MENU.AddDivider() {
    local cmd="MENU._add_item divider $*"
    ${cmd}
}

# -----------------------------------------------------------------------------
# Selects an item in the menu
#
# [IN]      arg1  - name of the menu
# [IN]      arg2  - name of the item to be selected
#
# The rest of the arguments are 'false' by default:
#
# [IN][OPT] show  - {true/false} whether to call MENU.Show
# [IN][OPT] flag1 - {true/false} whether to call the main manu's callback
# [IN][OPT] flag2 - {true/false} whether to call the selected item's callback
# [IN][OPT] mode  - call-mode of all the check button item's callbacks
#
# DEMO: For example, the following command selects 'Release' radio-button in
#       the demo 'Build' menu, shows the 'Build' menu, and calls the 'Release'
#       radio-button's callbacks:
#
# > MENU.Select build_menu Release true false true fals
#
# -----------------------------------------------------------------------------
MENU.Select() {
    if [[ $# -lt 2 ]]; then
        MENU._error "MENU.Select requires more arguments"
        return
    fi

    eval "${MENUEX["map"]}"
    eval "${map["$1"]}"

    [[ $# -gt 2 ]] && flagX=$3 || flagX='false'

    # We have to go through items[] first to check whether
    # the selected item is a check button type item
    eval "${context["items"]}"
    local check_button_set
    for i in "${!items[@]}"; do
        eval "${items["$i"]}"
        if [[ "${item["name"]}" == $2 ]] && [[ "${item["type"]}" == "check-button" ]]; then
            [[ "${item["checked"]}" == "on" ]] && item["checked"]="off" || item["checked"]="on"
            items["$i"]=$(declare -p item)
            context["items"]=$(declare -p items)

            [ "$flagX" == "true" ] && context["checked"]=$2
            MENU._log_info "CHECK BOX: '$2' state='${item["checked"]}'"

            check_button_set='true'
            break
        fi
    done

    # Set selected if the itme's type is the radio-button
    [[ ! "$check_button_set" ]] && context["selected"]=$2

    map[$1]=$(declare -p context)
    MENUEX["map"]=$(declare -p map)

    MENU._log_info "ARGS: $*"

    [[ $# -gt 3 ]] && flag1=$4 || flag1='false'
    [[ $# -gt 4 ]] && flag2=$5 || flag2='false'
    [[ $# -gt 5 ]] && mode=$6 || mode='false'

    # When called from an alias of an item there is an optional extra argument
    # true/false whether to call the main menu's callback in addition
    [[ $# -gt 6 ]] && flag1=$7

    if [ "$flagX" == "true" ]; then
        MENU._log_info "Show $1 f1=$flag1 f2=$flag2 mode=$mode"
        MENU.Show $1 $flag1 $flag2 $mode
    fi
}

# arguments are comming from the item's alias: $*
MENU._select() {
    MENU._log_info "ARGS: $*"

    [[ $# -gt 3 ]] && f1=$4 || f1='false'
    [[ $# -gt 4 ]] && f2=$5 || f2='false'
    [[ $# -gt 5 ]] && mode=$6 || mode='false'

    # an extra {true/false} might come from an alias argument
    # to call the main menu's callback
    [[ $# -gt 6 ]] && f1=$7

    MENU.Select $1 $2

    if [ $# -gt 2 ] && [ "$3" == "true" ]; then
        MENU._separator $1
        MENU.Show $1 $f1 $f2 $mode
        MENU._separator $1
    fi
}

# -----------------------------------------------------------------------------
# Performs an operation for all the check-button items in the menu
#
# [IN] name - a name/handle of the menu
# [IN] operation - a type of operation to perform on all the check-buttons:
#       check   - check all the check-button items
#       uncheck - un-check all the check-button itmes
#       flip    - flip the state of all the check-button itmes
#
# The rest of the arguments are 'false' by default:
#
# [IN][OPT] show  - {true/false} whether to call MENU.Show
# [IN][OPT] flag1 - {true/false} whether to call the main manu's callback
# [IN][OPT] flag2 - {true/false} whether to call the selected item's callback
# [IN][OPT] mode  - call-mode of all the check-button item's callbacks
#
# DEMO: For example, the following command flips all the check-buttons in the
#       demo 'Build' menu, shows the 'Build' menu, and calls all the checked
#       check-button's callbacks:
#
# > MENU.CheckButtonForAll build_menu flip true false false checked
#
# -----------------------------------------------------------------------------
MENU.CheckButtonForAll() {
    if [ $# -lt 2 ]; then
        MENU._error "MENU.CheckButtonForAll requires more arguments"
        return
    fi

    MENU._log_info "ARGS: $*"

    eval "${MENUEX["map"]}"
    eval "${map["$1"]}"
    eval "${context["items"]}"

    local changed='false'
    for i in "${!items[@]}"; do
        eval "${items["$i"]}"

        [ "${item["type"]}" != "check-button" ] && continue;

        local updated='false'
        case $2 in
            check)
                [ "${item["checked"]}" == "off" ] && item["checked"]="on"; updated='true'
                ;;
            uncheck)
                [ "${item["checked"]}" == "on" ] && item["checked"]="off"; updated='true'
                ;;
            flip)
                [ "${item["checked"]}" == "on" ] && item["checked"]="off" || item["checked"]="on"
                updated='true'
                ;;
        esac
        [ "$updated" == 'true' ] && items["$i"]=$(declare -p item); context["items"]=$(declare -p items); changed='true'
    done

    if [[ "$changed" == 'true' ]]; then
        map[$1]=$(declare -p context)
        MENUEX["map"]=$(declare -p map)
    fi

    [[ $# -gt 2 ]] && show=$3 || show='false'
    [[ $# -gt 3 ]] && flag1=$4 || flag1='false'
    [[ $# -gt 4 ]] && flag2=$5 || flag1='false'
    [[ $# -gt 5 ]] && mode=$6 || mode='false'

    if [ "$show" == "true" ]; then
        MENU.Show $1 $flag1 $flag2 $mode
    fi
}

# -----------------------------------------------------------------------------
# Displays the menu
#
# [IN] name - a name/handle of the menu
#
# The rest of the arguments are 'false' by default:
#
# [IN][OPT] flag1 - {true/false} whether to call the main manu's callback
# [IN][OPT] flag2 - {true/false} whether to call the selected item's callback
# [IN][OPT] mode  - call-mode of all the check button item's callbacks:
#            no (false)   - do not call any callback for any item
#            all (true)   - call all the callbacks for all check-button items
#                           regardless of its state
#            current      - call the callback of the check-button items that
#                           changes the state (.Select command only)
#            checked      - call all the callbacks for all checked check-buttons
#            unchecked    - call all the callbacks for all un-checked
#                           check-buttons
#
# DEMO: For example, the following command simply shows/displays the demo
#       'PLATFORM' menu w/o calling any callbacks:
#
# > MENU.Show pl_menu false false false
#
# -----------------------------------------------------------------------------
MENU.Show() {
    if [ $# -lt 1 ]; then
        MENU._error "MENU.Show requires more arguments"
        return
    fi

    MENU._log_info "ARGS: $*"

    eval "${MENUEX["map"]}"
    eval "${map["$1"]}"
    eval "${context["items"]}"

    if [ "${context["name"]}" != "MENU.Null" ]; then
        printf "${context["name.header"]}${context['name']/${context['alias']}/${smul}${context['alias']}${reset}}${context["name.footer"]} "
    fi

    local idx=0
    local -a callbacks=()
    local -a arguments=()

    # Store the main menu's callback to be called later
    if [ "$2" == "true" ] && [ "${context["callback"]}" != "MENU.Null" ]; then
        callbacks[$idx]=${context["callback"]}
        [[ "${context["name"]}" != "MENU.Null" ]] && arguments[$idx]+="$1 ${context["name"]}" || arguments[$idx]="$1"
        idx=$(($idx + 1))
    fi

    for i in "${!items[@]}"; do
        eval "${items["$i"]}"

        local name=${item["name"]}

        if [ "${context["align"]}" == "by.largest.item" ]; then
            name=$(MENU._string_pad ${item["name"]} ${context["item.length.max"]})
        fi

        local type=${item["type"]}

        if [ "$type" == "ln-break" ]; then
            printf "\n"
            local pad=$(MENU._string_pad '' ${#context['name']})
            printf "     $pad"
            continue
        fi

        if [ "$type" == "divider" ]; then
            local divider=${context["divider"]}
            printf "$divider "
            continue;
        fi

        if [ "$type" == "label" ]; then
            printf "$name "
            continue;
        fi

        local alias=${item["alias"]}
        local color=${context["color"]}
        local selected=${context["selected"]}

        if [ "$type" == "radio-button" ]; then
            if [ "${item["name"]}" == "$selected" ]; then
                local hi=${smul}${item["alias"]}${rmul}
                printf "${color}${bold}(${context["radio.symbol"]}) ${name/$alias/$hi}${reset} "

                # Store the radio button item's callback to be called later
                if [ "$3" == "true" ] && [ "${item["callback"]}" != "MENU.Null" ]; then
                    callbacks[$idx]=${item["callback"]}
                    arguments[$idx]="$1 ${item["name"]}"
                    idx=$(($idx + 1))
                fi
            else
                printf "( ) ${name/$alias/${smul}$alias${reset}} "
            fi
            continue;
        fi

        if [ "$type" == "check-button" ]; then
            local mode=$4
            if [ "${item["checked"]}" == "on" ]; then
                local hi=${smul}${item["alias"]}${rmul}
                printf "${color}${bold}[${context["check.symbol"]}] ${name/$alias/$hi}${reset} "
                if [ "$mode" == "checked" ] && [ "${context["callback"]}" != "MENU.Null" ]; then
                    callbacks[$idx]=${item["callback"]}
                    arguments[$idx]="$1 ${item["name"]} ${item["checked"]}"
                    idx=$(($idx + 1))
                fi
            else
                printf "[ ] ${name/$alias/${smul}$alias${reset}} "
                if [ "$mode" == "unchecked" ] && [ "${context["callback"]}" != "MENU.Null" ]; then
                    callbacks[$idx]=${item["callback"]}
                    arguments[$idx]="$1 ${item["name"]} ${item["checked"]}"
                    idx=$(($idx + 1))
                fi
            fi

            if [ "${context["checked"]}" == "${item["name"]}" ] && [ "$mode" == 'current' ] && [ "${context["callback"]}" != "MENU.Null" ]; then
                callbacks[$idx]=${item["callback"]}
                arguments[$idx]="$1 ${item["name"]} ${item["checked"]}"
                idx=$(($idx + 1))

                MENU._log_warning "mode: $mode context[checked]: ${context["checked"]}"
                MENU._log_warning "${item["callback"]} ${item["name"]} ${item["checked"]}"

                context["checked"]=''

                map[$1]=$(declare -p context)
                MENUEX["map"]=$(declare -p map)
            fi

            # Store all the check button item's callbacks to be called later
            if [ "$mode" == "all" ] || [ "$mode" == "true" ] && [ "${context["callback"]}" != "MENU.Null" ]; then
                callbacks[$idx]=${item["callback"]}
                arguments[$idx]="$1 ${item["name"]} ${item["checked"]}"
                idx=$(($idx + 1))
            fi

            continue;
        fi
    done

    printf "\n"

    # Last, call all the callbacks with its arguments that needs to be called
    for i in "${!callbacks[@]}"; do
        cb=${callbacks[$i]}
        [[ "${arguments[$i]}" ]] && cb+=" ${arguments[$i]}"
        ${cb}
    done
}

# -----------------------------------------------------------------------------
# Displays all the menus created
#
# All the optional arguments are 'false' by default:
#
# [IN][OPT] order - {true/false} whether to display all the menus in the order
#           of how the menus were created
# [IN][OPT] flag1 - {true/false} whether to call the main manu's callback
# [IN][OPT] flag2 - {true/false} whether to call the selected item's callback
# [IN][OPT] mode  - call-mode of all the check-button item's callbacks
#
# Remark: By default, the displaying order of the menus corresponds to the
#         order of how the keys of the bash's assosiative array are sorted
#
# -----------------------------------------------------------------------------
MENU.ShowAll() {
    [[ $# -gt 0 ]] && order=$1 || order='false'
    [[ $# -gt 1 ]] && f1=$2 || f1='false'
    [[ $# -gt 2 ]] && f2=$3 || f2='false'
    [[ $# -gt 3 ]] && mode=$4 || mode='false'

    local last_menu=''
    if [ "$order" == "true" ]; then
        eval "${MENUEX["order"]}"
        for i in "${!order[@]}"; do
            last_menu=${order[$i]}
            MENU._separator $last_menu true
            MENU.Show $last_menu $f1 $f2 $mode
        done
    else
        eval "${MENUEX["map"]}"
        for menu in "${!map[@]}"; do
            eval "${map["$menu"]}"
            last_menu=$menu
            MENU._separator $menu true
            MENU.Show $menu $f1 $f2 $mode
        done
    fi
    MENU._separator $last_menu true
}

# -----------------------------------------------------------------------------
# It's quite tricky to calculate accuratelly the menu's length because of such
# factors as ln-break and alignment
#
# [IN]  name   - the menu's handle
# [OUT] length - the length of the menu
#
# -----------------------------------------------------------------------------
MENU._calculate_menu_width() {
    if [ $# -lt 1 ]; then
        MENU._error "MENU._calculate_menu_width requires more arguments"
        return
    fi

    eval "${MENUEX["map"]}"
    eval "${map["$1"]}"
    eval "${context["items"]}"

    local max=0
    local length=0
    for i in "${!items[@]}"; do
        eval "${items["$i"]}"

        local name=$(MENU._string_pad ${item["name"]} ${context["item.length.max"]})
        case ${item['type']} in
            check-button | radio-button)
                ((length+=4)) # '[ ] ' or '( ) '
                ;;
            divider)
                ((length+=1)) # ' '
                ;;
            ln-break)
                [ $length -gt $max ] && max=$length
                continue
                ;;
        esac

        ((length+=${#name}))
        ((length+=1)) # ' ' after each item's name
    done

    [ $max -gt 0 ] && local width=$max || local width=$length

    if [[ "${context["name"]}" != "MENU.Null" ]]; then
        ((width+=${#context["name"]}))
        ((width+=4)) # ' * :'
    fi

    echo $width
}

# -----------------------------------------------------------------------------
# Prints out the menus' separator
#
# [IN]      menu    - the menu's handle
# [IN][OPT] largest - {true/false} whether to use the largest length
#                     of all the menus
#
# -----------------------------------------------------------------------------
MENU._separator() {
    if [ $# -lt 1 ]; then
        MENU._error "MENU._separator requires more arguments"
        return
    fi

    eval "${MENUEX["map"]}"
    eval "${map["$1"]}"

    local width=${context["menu.width"]}

    if [[ $width -lt 1 ]]; then
        width=$(MENU._calculate_menu_width $1)
        [[ $width -gt ${MENUEX["width"]} ]] && MENUEX["width"]=$width

        MENU._log_warning "re-calc the width: $width"

        context["menu.width"]=$width

        map[$1]=$(declare -p context)
        MENUEX["map"]=$(declare -p map)
    fi

    [[ $# -gt 1 && "$2" == "true" ]] && width=${MENUEX["width"]}

    cmd="printf -- '${context["separator.symbol"]}%.0s' {1..$width}"
    eval $cmd
    echo ""
}

# arguments are comming from the main menu's alias: $* f1 f2 mode
MENU._show() {
    [[ $# -gt 4 ]] && f1=$5 || f1='false'
    [[ $# -gt 5 ]] && f2=$6 || f2='false'
    [[ $# -gt 6 ]] && mode=$7 || mode='false'

    MENU._separator $1
    MENU.Show $1 $f1 $f2 $mode
    MENU._separator $1
}

MENU._debug_print() {
    eval "${map["$1"]}"
    echo "* $1:"
    for ctx_key in "${!context[@]}"; do
        if [ "$ctx_key" == "items" ]; then
            echo "  - [$ctx_key]:"
            eval "${context["$ctx_key"]}" # unpack: items variable
            for items_key in "${!items[@]}"; do
                echo "    + [$items_key]: ${items["$items_key"]}"
                eval "${items["$items_key"]}" # unpack: item variable
                # to iterate through item[] array
                #for indx in "${!item[@]}"; do
                #    printf "      ♦ [$indx]: ${item["$indx"]}\n"
                #done
            done
        else
            printf "  - [$ctx_key]: ${context["$ctx_key"]}${reset}\n"
        fi
    done
}

MENU._debug_print_all() {
    [[ "$MENUBUILD" == "Release" ]] && return

    eval "${MENUEX["map"]}"
    for key in "${!map[@]}"; do
        MENU._debug_print $key
    done
}

# ---------------------------------------------------------------------------------------------------------------------
#
# Demo Example
#
# ---------------------------------------------------------------------------------------------------------------------


# ********************   TODO LIST   ********************
# TODO: SetStyleEx: print separator true/false, true - by default
# TODO: separator char, '-' by default
# TODO: radio-box open char '(', close char ')'
# TODO: check-box open char '[', close char ']'
# TODO: lower case alias ???
# ********************   TODO LIST   ********************


#source menu_ex

alias demo='MENU.Demo'
alias dev='MENU.ShowAll true'

MENU.Demo() {
    null='MENU.Null'

    #
    # Demo menu 'PLATFORM'
    #

    # -----------------------------------------------------------------------------------------------------------------
    # Create a menu
    #
    # 1           handle                     - a name/handle of the menu to be used w/ the API
    # 2 [OPT]       |     name               - a displayed name of the menu
    # 3 [OPT]       |      |    alias        - an alias to be created that displays the menu
    # 4 [OPT]       |      |     |  callback - a function to be called when the menu is displayed
    MENU.Create pl_menu PLATFORM PL MENU.DemoMainMenu
    #MENU.Create pl_menu $null PL MENU.DemoMainMenu
    #MENU.Create pl_menu $null $null MENU.DemoMainMenu
    #MENU.Create pl_menu

    # -----------------------------------------------------------------------------------------------------------------
    # Under the hood 'PL' is just an alias for: 'MENU.Show pl_menu'
    #
    # 1 [OPT]  flag1           - whether to call the main menu's callback
    # 2 [OPT]   |    flag2     - whether to call the selected radio button item's callback
    # 3 [OPT]   |     |   mode - call-mode of all the check button item's callbacks, for modes see documentation for .Show
    # > PL    false false all
    #
    # 'PL' alias usage examples:
    # > PL                 - displays the menu
    # > PL true            - displays the menu + calls the menu's callback
    # > PL false true      - displays the menu + calls the selected radio button item's callback
    # > PL true true       - displays the menu + calls both the selected item and the main menu's callbacks
    # > PL false false all - displays the menu + calls all the radio button item's callbacks
    # -----------------------------------------------------------------------------------------------------------------

    # -----------------------------------------------------------------------------------------------------------------
    # Set the menu's style (replace the default style)
    #
    # 1           handle                                               - a name/handle of the menu to be used w/ the API
    # 2 [OPT]       |    divider                                       - devider to be used w/ .AddDivider ('|' by default)
    # 3 [OPT]       |      |        alignment                          - alignent of the item names (none by default)
    # 4 [OPT]       |      |           |          color                - the color of hightlighted items (green by default)
    # 5 [OPT]       |      |           |            |    symbol1       - the select symbol for the radio button when selected
    # 6 [OPT]       |      |           |            |      |   symbol2 - the check symbol for the check button when checked
    #MENU.SetStyle pl_menu default by.largest.item ${red} '○' default
    # -----------------------------------------------------------------------------------------------------------------

    # -----------------------------------------------------------------------------------------------------------------
    # Set the extra style of the menu (replace the default style)
    # 1            handle                                                - a name/handle of the menu to be used w/ the API
    # 2 [OPT]         |   separator.show                                 - xxx
    # 3 [OPT]         |     |  symbol.sep                                - devider to be used w/ .AddDivider ('|' by default)
    # 4 [OPT]         |     |    |  name.header                          - alignent of the item names (none by default)
    # 5 [OPT]         |     |    |    |  name.footer                     - the color of hightlighted items (green by default)
    # 6 [OPT]         |     |    |    |    | symbol.radio.start          - the select symbol for the radio button when selected
    # 7 [OPT]         |     |    |    |    |   | symbol.radio.end        - the check symbol for the check button when checked
    # 8 [OPT]         |     |    |    |    |   |   | symbol.chk.start    - the check symbol for the check button when checked
    # 9 [OPT]         |     |    |    |    |   |   |   |  symbol.chk.end - the check symbol for the check button when checked
    #MENU.SetStyleEx MENU1 true '-' " * " ":" '(' ')' '[' ']'
    #
    # For example you want to create a menu that looks like this:
    #  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #  => MENU - / / Item1 /*/ Item2 / / Item3 === | | chk1 |+| chk2
    #  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #
    #MENU.SetStyleEx MENU1 true '~' "=>" " -" '/' '/' '|' '|'
    #MENU.SetStyle MENU1 "===" default ${red} '*' '+'
    # -----------------------------------------------------------------------------------------------------------------

    # -----------------------------------------------------------------------------------------------------------------
    # Add a radio-button item into the menu
    #
    # 1               handle                    - a name/handle of the menu to be used w/ the API
    # 2                 |    name               - an item's name to be added into the menu
    # 3 [OPT]           |     |    alias        - an alias to be created that triggers the item's callback
    # 4 [OPT]           |     |     |  callback - a function to be called when an item is selected
    MENU.AddRadioButton pl_menu Linux nux MENU.DemoPlLinuxCb
    #MENU.AddRadioButton pl_menu Linux $null MENU.DemoPlLinuxCb
    #MENU.AddRadioButton pl_menu Linux
    #
    # In the invocation example #2, there is no alias for item 'Linux', so the only way to call it is by using
    # the .Select command, like so: MENU.Select pl_menu Linux true false true
    # Please, look into .Select command demo to understand all the flags
    #
    # -----------------------------------------------------------------------------------------------------------------
    # Under the hood 'nux' is just an alias for: 'MENU.Select pl_menu Linux true false true'
    #
    # 1 [OPT]  flag1     - whether to call the main menu's callback
    # 2 [OPT]   |   mode - call-mode of the check button callbacks [no (false), all (true), checked, unchecked]
    # > nux    true no
    #
    # 'nux' alias usage examples:
    # > nux          - selects 'Linux' item, displays the 'PLATFORM' menu and triggers the 'Linux' item's callback
    # > nux true     - all the above + triggers the 'PLATFORM' menu's callback
    # > nux true all - all the above + triggers all the check button item's callbacks (if any)
    # -----------------------------------------------------------------------------------------------------------------

    MENU.AddRadioButton pl_menu rpi3 pi3 MENU.DemoPlRpi3Cb
    MENU.AddDivider pl_menu
    #MENU.AddLnBreak pl_menu
    MENU.AddLabel pl_menu QEMU:
    MENU.AddRadioButton pl_menu v8 v8 MENU.DemoPlQemuCb
    MENU.AddRadioButton pl_menu arm32 arm MENU.DemoPlQemuCb

    # -----------------------------------------------------------------------------------------------------------------
    # Select an item of the menu
    #
    #           handle                             - a name/handle of the menu to be used w/ the API
    #             |    name                        - a name of an item to be set as 'selected' in the menu
    #             |     |   show                   -
    #             |     |    |    flag1            -
    #             |     |    |     |    flag2      -
    #             |     |    |     |     |    mode -
    MENU.Select pl_menu rpi3 false false true no
    # -----------------------------------------------------------------------------------------------------------------

    # -----------------------------------------------------------------------------------------------------------------
    # Show/display the menu
    #
    #         handle                - a name/handle of the menu to be used w/ the API
    #           |   flag1           - whether to call the main menu's callback
    #           |     |  flag2      - whether to call the selected radio button item's callback
    #           |     |    |  mode  - call mode of the check button callbacks [no (false), all (true), checked, unchecked]
    MENU.Show pl_menu true true all

    #
    # mode:
    #  no (false)   - do not call any callback for any check button itmes
    #  all (true)   - call all the callbacks for all check button items regardless of the state
    #  current      - call the callback of the check button item that changes the state (.Select only)
    #  checked      - call all the callbacks for all checked check button items
    #  unchecked    - call all the callbacks for all un-checked check button items
    #
    # -----------------------------------------------------------------------------------------------------------------

    MENU.Create build_menu Build Build MENU.DemoMainMenu

    #
    # if there is no alias for the menu you can call it through
    # MENU API directly or create your own alias:
    #
    # > MENU.Show build_menu
    #

    #
    # Demo menu 'Build'
    #
    MENU.AddRadioButton build_menu Debug dbg MENU.DemoBuildChange
    MENU.AddRadioButton build_menu Release rls MENU.DemoBuildChange
    MENU.AddDivider build_menu
    MENU.AddCheckButton build_menu Pedantic Pedant MENU.DemoBuildGccFlags
    MENU.AddCheckButton build_menu Wall all MENU.DemoBuildGccFlags
    MENU.AddCheckButton build_menu Werror err MENU.DemoBuildGccFlags
    MENU.AddCheckButton build_menu fPIC PIC MENU.DemoBuildGccFlags
    MENU.AddCheckButton build_menu isoC99 iso MENU.DemoBuildGccFlags
    MENU.Select build_menu Debug false
    MENU.Select build_menu Wall false
    MENU.Select build_menu Werror false
    MENU.Show build_menu true true all

    #
    # Demo menu 'LOGS'
    #
    MENU.Create logs_menu LOGS LOGS MENU.DemoMainMenu
    MENU.SetStyle logs_menu default by.largest.item

    MENU.AddRadioButton logs_menu FATAL $null MENU.DemoLogsCb

    MENU.AddRadioButton logs_menu SEVERE $null MENU.DemoLogsCb
    MENU.AddRadioButton logs_menu WARNING $null MENU.DemoLogsCb
    MENU.AddRadioButton logs_menu INFO $null MENU.DemoLogsCb
    MENU.AddLnBreak logs_menu
    MENU.AddRadioButton logs_menu FINE $null MENU.DemoLogsCb
    MENU.AddRadioButton logs_menu FINER $null MENU.DemoLogsCb
    MENU.AddRadioButton logs_menu FINEST $null MENU.DemoLogsCb
    MENU.AddRadioButton logs_menu OFF $null MENU.DemoLogsCb
    MENU.Select logs_menu INFO false
    MENU.Show logs_menu true true

    MENU._debug_print_all
}

# -----------------------------------------------------------------------------------------------------------------
# The Demo Menu's Callbacks
# -----------------------------------------------------------------------------------------------------------------

# [IN] handle - the menu's name/handle
# [IN] name   - the menu's name (if specified)
MENU.DemoMainMenu() {
    MENU._separator $1
    echo " $2.Callback..."
    echo ' ...'
}

# [IN]      handle - the menu's name/handle
# [IN]      name   - the name of the selected item
# [IN][OPT] state  - {on, off} item's state (check-button type only)
MENU.DemoPlQemuCb() {
    MENU._separator $1
    echo " PL.Qemu.$2.Callback..."
    echo ' ...'
}

MENU.DemoPlLinuxCb() {
    if [[ "$2" != 'Linux' ]]; then
        MENU._error "Wrong callback!"
        return
    fi
    MENU._separator $1
    echo " PL.Linux.Callback..."
    echo ' ...'
}

MENU.DemoPlRpi3Cb() {
    MENU._separator $1
    echo " PL.$2.Callback..."
    echo ' ...'
}

MENU.DemoBuildChange() {
    MENU._separator $1
    echo " Build.$2.Callback..."

    case $2 in
        Debug)
            echo ' ...'
            ;;
        Release)
            echo ' ...'
            ;;
    esac

}

MENU.DemoBuildGccFlags() {
    MENU._separator $1
    echo " PL.$2.state.[$3].Callback..."

    case $2 in
        Pedantic)
            echo ' ...'
            ;;
        Wall)
            echo ' ...'
            ;;
        Werror)
            echo ' ...'
            ;;
        fPIC)
            echo ' ...'
            ;;
        isoC99)
            echo ' ...'
            ;;
    esac

}

MENU.DemoLogsCb() {
    MENU._separator $1
    echo " LOGS.$2.Callback..."

    case $2 in
        FATAL)
            echo ' ...'
            ;;
        SEVERE)
            echo ' ...'
            ;;
        WARNING)
            echo ' ...'
            ;;
        INFO)
            echo ' ...'
            ;;
        FINE)
            echo ' ...'
            ;;
        FINER)
            echo ' ...'
            ;;
        FINEST)
            echo ' ...'
            ;;
        OFF)
            echo ' ...'
            ;;
    esac
}

# -----------------------------------------------------------------------------------------------------------------

demo

#
# run 'dev' alias to see all the demo menus
# > dev
#