#!/bin/sh

# -------------------------------------------------------------------
#
# Alex Demyankov
# alex.demyankov@gmail.com
#
# -------------------------------------------------------------------

# Global Map that holds all the menus created
unset MENUMAP
declare -A MENUMAP

# Change to 'Debug' if you need logs and trace output
unset MENUMODE
declare -g MENUMODE='Debug'

# Runs a demo example menu
alias demo='MENU.Demo'

# -------------------------------------------------------------------

# -------------------------------------------------------------------
# All kinds of cool stuff for environment
#
# Num  Colour    define          R G B
# 0    black     COLOR_BLACK     0,0,0
# 1    red       COLOR_RED       1,0,0
# 2    green     COLOR_GREEN     0,1,0
# 3    yellow    COLOR_YELLOW    1,1,0
# 4    blue      COLOR_BLUE      0,0,1
# 5    magenta   COLOR_MAGENTA   1,0,1
# 6    cyan      COLOR_CYAN      0,1,1
# 7    white     COLOR_WHITE     1,1,1
#
# -------------------------------------------------------------------
black=`tput setaf 0`
red=`tput setaf 1`
green=`tput setaf 2`
yellow=`tput setaf 3`
blue=`tput setaf 4`
magenta=`tput setaf 5`
cyan=`tput setaf 6`
white=`tput setaf 7`

reset=`tput sgr0`

bold=`tput bold`  # Select bold mode
dim=`tput dim`    # Select dim (half-bright) mode
smul=`tput smul`  # Enable underline mode
rmul=`tput rmul`  # Disable underline mode
smso=`tput smso`  # Enter standout (bold) mode
rmso=`tput rmso`  # Exit standout mode
rev=`tput rev`    # Turn on reverse video mode

#
# Functions acronims
#
# [IN] - input argument
# [OUT] - output result
# [OPT] - optional argument
#
# Functions named MENU._lover_case are private and not supposed to be
# called directly
#

# -------------------------------------------------------------------
# Pads a string with 'space' chars to the length specified
#
# [IN] arg1 - a string to pad
# [IN] arg2 - the length of the output string
# [OUT] returns the padded arg1 string
#
# -------------------------------------------------------------------
MENU._string_pad() {
    local len=$(($2 - ${#1}))
    pad=`printf '%*s' "$len" | tr ' ' " "`
    echo "$1$pad"
}

# -------------------------------------------------------------------
# Converts a string to an upper chars string
#
# [IN] arg1 - string to convert
# [OUT] returns a converted string
#
# -------------------------------------------------------------------
MENU._to_upper() {
    echo "$(echo ${1} | awk '{print toupper($0)}')"
}

# Returns 'true' when debugging/testing
MENU._is_debug() {
    [[ "$MENUMODE" == "Release" ]] && echo '' || echo 'true'
}

MENU._log() {
    local marker="${green}${bold}INFO${reset}:"
    [[ "$1" == "WARNING" ]] && marker="${yellow}${bold}WARNING${reset}:"
    [[ "$1" == "SEVERE" ]] && marker="${red}${bold}SEVERE${reset}:"
    shift
    echo "${FUNCNAME[2]}: $marker $*"
}

MENU._error() {
  MENU._log SEVERE $1
}

MENU._warning() {
  MENU._log WARNING $1
}

MENU._log_info() {
    [[ "$(MENU._is_debug)" ]] && MENU._log INFO $1
}

# -------------------------------------------------------------------
# Creates a new menu
#
# [IN]      arg1 - a name/handle of the menu to be used w/ the API
# [IN][OPT] arg2 - a menu's name to be displayed
# [IN][OPT] arg3 - short name as a selector for the menu's name
# [IN][OPT] arg4 - a callback to be called when the menu is selected
#
# Remark: arg3 creates an alias for the menu unless the alias already
# exists in the environment;
#
# Example:
# MENU.Create menu1 PLATFORM PL
#
# Remark: alias PL simply shows the menu and by default it does not
#         fire any callbacks. PL alias is simply a substitution for:
#
#         MENU.Show menu1 false false flase
#
#         MENU.Show has flags that can trigger any type of callbacks.
#
# For example:
#   ~$ MENU.Show menu1 true true true
#         which is equivalent to:
#   ~$ PL true true true
#         it will
#         trigger all callbacks (main menu's callback, currently
#         selected radio box callback and all callbacks for all the
#         check boxies)
#         So, you can do tricks with aliases, like so:
#         alias pl='PL true true'
# -------------------------------------------------------------------
MENU.Create() {
    if [[ $# -lt 1 ]]; then
        MENU._error "MENU.Create requires more arguments"
        return
    fi

    local -A context=()
    context["name"]=''
    context["alias"]=''
    context["callback"]=''

    # Optional arguments
    [[ $# -gt 1 ]] && context["name"]=$2
    [[ $# -gt 2 ]] && context["alias"]=$3
    [[ $# -gt 3 ]] && context["callback"]=$4

    local -a items=()
    context["items"]=$(declare -p items)

    MENUMAP[$1]=$(declare -p context)

    local default="MENU.SetStyle $1"
    ${default}

    # Create an alias to display the menu
    if [[ "${context['alias']}" != '' ]] && [[ "${context['callback']}" != '' ]]; then
        if [ `alias | grep ${context['alias']} | wc -l` != 0 ]; then
            MENU._warning "Alias '${context['alias']}' already exists in the env and will not be reasigned!"
            [[ ! "$(MENU._is_debug)" ]] && return
        fi
        alias "${context['alias']}"="MENU._show $*"
    fi
}

# -------------------------------------------------------------------
# Sets the style for a menu
#
# [IN]      arg1 - a name/handle of the menu to be used w/ the API
# [IN][OPT] arg2 - divider ('|' by default)
# [IN][OPT] arg3 - alignment (none by default):
#             'by-largest' - aligns all the menu's items by the
#                            length of the largest item's name
# [IN][OPT] arg4 - the color of hightlighted items (green by default)
# [IN][OPT] arg5 - the symbol for the radio box (menu) selected
#                  ('♦' by default)
# [IN][OPT] arg6 - the symbol for the check box selected
#                  ('x' by default)
#
# Remark: default can be passed as any [OPT] argument, which will set
#         the default value for the style parameter
#
# Example:
# MENU.SetStyle menu1 default default ${red} '○' default
#
# -------------------------------------------------------------------
MENU.SetStyle() {
    if [[ $# -lt 1 ]]; then
      MENU._error "MENU.SetStyle requires more arguments"
      return
    fi

    eval "${MENUMAP["$1"]}"

    # By default
    context["divider"]='|'
    context["align"]=''
    context["color"]=${green}
    context["radio-symbol"]='♦'
    context["check-symbol"]='x'
    context["max-len"]=0

    # Optional arguments
    [[ $# -gt 1 && "$2" != "default" ]] && context["divider"]=$2
    [[ $# -gt 2 && "$3" != "default" ]] && context["align"]=$3
    [[ $# -gt 3 && "$4" != "default" ]] && context["color"]=$4
    [[ $# -gt 4 && "$5" != "default" ]] && context["radio-symbol"]=$5
    [[ $# -gt 5 && "$6" != "default" ]] && context["check-symbol"]=$6

    MENUMAP[$1]=$(declare -p context)
}

# -------------------------------------------------------------------
# Add a item into a menu
#
# [IN]      arg1 - type of the item, supported types are:
#           'radio-box', 'check-box', 'divider', 'ln-break'
# [IN]      arg2 - a name/handle of the menu to be used w/ the API
# [IN]      arg3 - a name of an item to be added into the menu
# [IN][OPT] arg4 - short name as a selector for the menu's item
# [IN][OPT] arg5 - callback to be called when the item is selected
#
# Remark: arg4 creates an alias for the menu's item unless the alias
# already exists
#
# Remark: arg3 has to be part of the item name to be highlighted,
# if arg2 = 'Item1', and arg3 = 'em1' then the 'em1' will be the
# alias and will be highlighted when the menu is displayed; if the
# selector is not part of the name, e.g. 'I1' then the alias still
# will be creaded but the selector in the menu will not be highlighted
#
# If arg3 is not specified then the item can be selected via the menu
# alias + the name of the item
#
# Remark: arg4 callback when is called there are 2 arguments passed
# into the callbak: [IN] arg1 - menu name, [IN] arg2 - item name;
# For an example, please, look MENU._dummy_callback
#
# If arg4 is not specified then MENU._dummy_callback is called for
# an item
#
# Example:
# MENU.AddRadioBox menu1 Item1 m1 Menu1Item1_Cb
# MENU.AddRadioBox menu1 Item2 m2 Menu1Item2_Cb
#
# -------------------------------------------------------------------
MENU._add_item() {
    if [[ $# -lt 2 ]]; then
        MENU._error "MENU.AddItem requires more arguments"
        return
    fi

    MENU._log_info "args: $*"

    # if it's a 'divider' or 'ln-break'
    #[[ $# -gt 2 ]] && eval item_name="$3" || item_name=''

    local -A item=()
    item["type"]=$1
    item["name"]=$item_name
    item["alias"]=$4
    item["callback"]=$5
    item["checked"]='off' # used for 'checkbox' mode only

    eval "${MENUMAP["$2"]}"
    eval "${context["items"]}"

    items[${#items[@]}]=$(declare -p item)
    context["items"]=$(declare -p items)
    [[ ${context["item-len-max"]} -lt ${#item["name"]} ]] && context["item-len-max"]=${#item["name"]}
    MENUMAP[$2]=$(declare -p context)

    [[ "${item['type']}" != "radio-box" && "${item['type']}" != "check-box" ]] && return

    # Create an alias to call the menu's callback
    if [[ "${item['alias']}" != '' ]] && [[ "${item['callback']}" != '' ]]; then
        if [ `alias | grep ${item['alias']} | wc -l` != 0 ]; then
            MENU._warning "Alias '${item['alias']}' already exists in the env and will not be reasigned!"
            [[ ! "$(MENU._is_debug)" ]] && return
        fi

        # See Select command for the flags:                      X    1    2    mode
        [[ "${item['type']}" == "radio-box" ]] && local flags="true false true false" || local flags="true false false current"
        alias "${item['alias']}"="MENU.Select $2 \"${item["name"]}\" $flags"
    fi
}

MENU.AddRadioBox() {
    # A trick to pass an item's name string as a variable to be able
    # to use spaces in the name string, e.g. "Menu Item 1"
    local menu_name=$1
    local item_name="$2"
    shift 2
    local cmd="MENU._add_item radio-box $menu_name \"\${item_name}\" $*"
    ${cmd}
}

MENU.AddCheckBox() {
    local menu_name=$1
    local item_name="$2"
    shift 2
    local cmd="MENU._add_item check-box $menu_name \"\${item_name}\" $*"
    ${cmd}
}

MENU.AddLnBreak() {
    local cmd="MENU._add_item ln-break $*"
    ${cmd}
}

MENU.AddDivider() {
    local cmd="MENU._add_item divider $*"
    ${cmd}
}

# -------------------------------------------------------------------
# Specifies a menu's item to be selected by default
#
# [IN]      arg1  - name of the menu
# [IN]      arg2  - name of the item to be selected
# [IN][OPT] flagX - whether to call MENU.Show
# [IN][OPT] flag1 - whether to call the main manu's callback
# [IN][OPT] flag2 - whether to call the selected item's callback
# [IN][OPT] flag3 - whether to call all callbacks of check box items
#
# Remark: The menu's item callback is launched when MENU.Show is
#         executed
#
# -------------------------------------------------------------------
MENU.Select() {
    if [[ $# -lt 2 ]]; then
        MENU._error "MENU.Select requires more arguments"
        return
    fi

    eval "${MENUMAP["$1"]}"

    # We have to go through items[] first to check whether
    # the selected item is a check box type item
    eval "${context["items"]}"
    local check_box_set
    for i in "${!items[@]}"; do
        eval "${items["$i"]}"
        if [[ "${item["name"]}" == $2 ]] && [[ "${item["type"]}" == "check-box" ]]; then
            [[ "${item["checked"]}" == "on" ]] && item["checked"]="off" || item["checked"]="on"
            items["$i"]=$(declare -p item)
            context["items"]=$(declare -p items)
            check_box_set='true'
            MENU._log_info "CHECK BOX: '$2' state='${item["checked"]}'"
            break
        fi
    done

    # Set selected if radio box type item
    [[ ! "$check_box_set" ]] && context["selected"]=$2

    MENUMAP[$1]=$(declare -p context)

    MENU._log_info "ARGS: $*"

    [[ $# -gt 2 ]] && flagX=$3 || flagX='false'
    [[ $# -gt 3 ]] && flag1=$4 || flag1='false'
    [[ $# -gt 4 ]] && flag2=$5 || flag2='false'
    [[ $# -gt 5 ]] && mode=$6 || mode='false'

    # When called from an alias of an item there is an optional extra argument
    # true/false whether to call the main menu's callback in addition
    [[ $# -gt 6 ]] && flag1=$7 || flag1='false'

    if [[ "$flagX" == "true" ]]; then
        MENU._log_info "Show $1 f1=$flag1 f2=$flag2 mode=$mode"
        MENU.Show $1 $flag1 $flag2 $mode
    fi
}

# -------------------------------------------------------------------
# Displays a menu
#
# [IN] arg1 - a name/handle of the menu to be used w/ the API
#
# The rest of the [BOOLEAN] arguments are 'false' by default:
#
# [IN][OPT] flag1 - whether to call the main manu's callback
# [IN][OPT] flag2 - whether to call the selected item's callback
# [IN][OPT] mode  -
#
# -------------------------------------------------------------------
MENU.Show() {
    if [[ $# -lt 1 ]]; then
        MENU._error "MENU.Show requires more arguments"
        return
    fi

    echo "------------------------------------------------------------------------"
    MENU._log_info "ARGS: $*"

    eval "${MENUMAP["$1"]}"

    if [ ${context['name']} != "" ]; then
        printf " * ${context['name']/${context['alias']}/${smul}${context['alias']}${reset}}: "
    fi

    eval "${context["items"]}"

    local idx=0
    local -a callbacks=()
    local -a arguments=()

    # Store the main menu's callback to be called later
    if [[ "$2" == "true" ]] && [[ "${context["callback"]}" != "" ]]; then
        callbacks[$idx]=${context["callback"]}
        arguments[$idx]=${context["name"]}
        idx=$(($idx + 1))
    fi

    for i in "${!items[@]}"; do
        eval "${items["$i"]}"

        local name=${item["name"]}

        if [ "${context["align"]}" == "by-largest" ]; then
            name=$(MENU._string_pad ${item["name"]} ${context["item-len-max"]})
        fi

        local type=${item["type"]}

        if [ "$type" == "ln-break" ]; then
            printf "\n"
            local pad=$(MENU._string_pad '' ${#context['name']})
            printf "     $pad"
            continue
        fi

        if [ "$type" == "divider" ]; then
            local divider=${context["divider"]}
            printf "$divider "
            continue;
        fi

        local alias=${item["alias"]}
        local color=${context["color"]}
        local selected=${context["selected"]}

        if [ "$type" == "radio-box" ]; then
            if [ "${item["name"]}" == "$selected" ]; then
                local hi=${smul}${item["alias"]}${rmul}
                printf "${color}${bold}(${context["radio-symbol"]}) ${name/$alias/$hi}${reset} "

                # Store the radio box item's callback to be called later
                if [[ "$3" == "true" ]] && [[ "${item["callback"]}" != "" ]]; then
                    callbacks[$idx]=${item["callback"]}
                    arguments[$idx]=${item["name"]}
                    idx=$(($idx + 1))
                fi
            else
                printf "( ) ${name/$alias/${smul}$alias${reset}} "
            fi
            continue;
        fi

        if [ "$type" == "check-box" ]; then
            local mode=$4
            if [ "${item["checked"]}" == "on" ]; then
                local hi=${smul}${item["alias"]}${rmul}
                printf "${color}${bold}[${context["check-symbol"]}] ${name/$alias/$hi}${reset} "
                if [[ "$mode" == "checked" ]]; then
                    callbacks[$idx]=${item["callback"]}
                    arguments[$idx]="${item["name"]} ${item["checked"]}"
                    idx=$(($idx + 1))
                fi
            else
                printf "[ ] ${name/$alias/${smul}$alias${reset}} "
                if [ "$mode" == "unchecked" ]; then
                    callbacks[$idx]=${item["callback"]}
                    arguments[$idx]="${item["name"]} ${item["checked"]}"
                    idx=$(($idx + 1))
                fi
            fi

            # Store all the check box item's callbacks to be called later
            if [ "$mode" == "all" ] || [ "$mode" == "true" ]; then
                callbacks[$idx]=${item["callback"]}
                arguments[$idx]="${item["name"]} ${item["checked"]}"
                idx=$(($idx + 1))
            fi

            continue;
        fi
    done

    printf "\n"
    echo "------------------------------------------------------------------------"

    # Last, call all the callbacks that needs to be called
    for i in "${!callbacks[@]}"; do
        cb=${callbacks[$i]}
        [[ "${arguments[$i]}" ]] && cb+=" ${arguments[$i]}"
        ${cb}
    done
}

# arguments are comming from the menu's alias: $* f1 f2 f3
MENU._show() {
    [[ $# -gt 4 ]] && f1=$5 || f1='false'
    [[ $# -gt 5 ]] && f2=$6 || f2='false'
    [[ $# -gt 6 ]] && f3=$7 || f3='false'
    MENU.Show $1 $f1 $f2 $f3
}

MENU._debug_print() {
    [[ ! "$(MENU._is_debug)" ]] && return
    for menu_key in "${!MENUMAP[@]}"; do
        echo '----------------------------------------------------------------------------------------'
        eval "${MENUMAP["$menu_key"]}" # unpack: context variable
        echo "* $menu_key:"
        for ctx_key in "${!context[@]}"; do
            if [ "$ctx_key" == "items" ]; then
                echo "  - [$ctx_key]:"
                eval "${context["$ctx_key"]}" # unpack: items variable
                for items_key in "${!items[@]}"; do
                    echo "    + [$items_key]: ${items["$items_key"]}"
                    eval "${items["$items_key"]}" # unpack: item variable
                    for indx in "${!item[@]}"; do
                        printf "      ♦ [$indx]: ${item["$indx"]}\n"
                    done
                done
            else
                printf "  - [$ctx_key]: ${context["$ctx_key"]}${reset}\n"
            fi
        done
    done
    echo '----------------------------------------------------------------------------------------'
}

# -------------------------------------------------------------------
# Demo Example
#

MENU.Demo() {
    # ----------------------------------------------------------------------------------------
    # Create a menu
    #
    #           handle                      - a name/handle of the menu to be used w/ the API
    #             |     item                - a name of an item to be added into the menu
    #             |      |    alias         - short name as a selector for the menu's item
    #             |      |     |  callback  - callback to be called when the item is selected
    MENU.Create menu1 PLATFORM PL MENU.DemoMenuCb
    # ----------------------------------------------------------------------------------------

    # --------------------------------------------------------------------------------------------------------------
    # Set the style for a menu
    #
    # 1           handle                                        - a name/handle of the menu to be used w/ the API
    # 2 [OPT]       |    divider                                - devider to be used w/ .AddDivider ('|' by default)
    # 3 [OPT]       |      |    alignment                       - alignent of the item names (none by default)
    # 4 [OPT]       |      |       |       color                - the color of hightlighted items (green by default)
    # 5 [OPT]       |      |       |         |  symbol1         - the select symbol for the radio box when selected
    # 6 [OPT]       |      |       |         |     |  symbol2   - the check symbol for the check box when checked
    #MENU.SetStyle menu1 default by-largest ${red} '○' default
    # --------------------------------------------------------------------------------------------------------------

    # ----------------------------------------------------------------------------------------
    # Add a radio-box item into the menu
    #
    #                handle                     - a name/handle of the menu to be used w/ the API
    #                  |   item                 - a name of an item to be added into the menu
    #                  |    |    alias          - short name as a selector for the menu's item
    #                  |    |     |  callback   - callback to be called when the item is selected
    MENU.AddRadioBox menu1 Linux nux MENU.DemoPlLinuxCb
    # ----------------------------------------------------------------------------------------

    MENU.AddRadioBox menu1 Embed mbed MENU.DemoPlEmbedCb

    #MENU.AddLnBreak Menu1
    #MENU.AddDivider Menu1
    #MENU.AddCheckBox menu1 "Nx mode" Nx MENU.DemoPlNxCheckCb
    #MENU.AddCheckBox menu1 "PP mode" PP MENU.DemoPlPPCheckCb
    MENU.AddCheckBox menu1 "Nx-Mode" Nx MENU.DemoPlCheckBoxCb
    MENU.AddCheckBox menu1 "PP-Mode" PP MENU.DemoPlCheckBoxCb
    #MENU.AddDivider Menu1
    #MENU.AddLnBreak Menu1

    MENU.AddRadioBox menu1 Qemu mu MENU.DemoPlQemuCb

    # ----------------------------------------------------------------------------------------
    # Select an item of the menu
    #
    #           handle      - a name/handle of the menu to be used w/ the API
    #             |   item  - a name of an item to be set as 'selected' in the menu
    MENU.Select menu1 Qemu false
    # ----------------------------------------------------------------------------------------

    MENU.Select menu1 Nx-Mode false

    MENU._debug_print

    # ----------------------------------------------------------------------------------------
    # Show/display the menu
    #
    #         handle                - a name/handle of the menu to be used w/ the API
    #           |   flag1           - whether to call the main menu's callback
    #           |     |  flag2      - whether to call the selected radio box item's callback
    #           |     |    |  mode  - call mode of the check box callbacks [no (false), all (true), current, checked, unchecked]
    MENU.Show menu1 true true all
    #
    # no (false)    - do not call any callback for any check box itmes
    # all (true)    - call all the callbacks for all check box items regardless of the state
    # current       - call the callback of the check box item that changes the state (.Select only)
    # checked       - call all the callbacks for all checked check box items
    # unchecked     - call all the callbacks for all un-checked check box items
    #
    # ----------------------------------------------------------------------------------------


    #
    #
    #
    #
    #

: '
    MENU.Create menu2 Build Build PlatformMenu_Cb
    MENU.AddRadioBox menu2 Debug bug Menu1Item3_Cb
    MENU.AddRadioBox menu2 Release se Menu1Item3_Cb
    MENU.AddDivider menu2
    MENU.AddCheckBox menu2 Pedantic Pedant Menu1Item1_Cb
    MENU.AddCheckBox menu2 Wall all Menu1Item1_Cb
    MENU.AddCheckBox menu2 Werror err Menu1Item1_Cb
    MENU.AddCheckBox menu2 "ISO C99" iso Menu1Item1_Cb
    MENU.Select menu2 Debug
    MENU.Check menu2 Pedantic
'
    #MENU.Show menu2

}

# -------------------------------------------------------------------

# Callbacks

MENU.DemoMenuCb() {
    echo " * $1: Main menu Callback..."
    echo ' * ...'
    echo '------------------------------------------------------------------------'

}

MENU.DemoPlQemuCb() {
    echo " * PL.$1: Callback..."
    echo ' * ...'
    echo '------------------------------------------------------------------------'
}

MENU.DemoPlLinuxCb() {
    echo " * PL.$1: Callback..."
    echo ' * ...'
    echo '------------------------------------------------------------------------'
}

MENU.DemoPlEmbedCb() {
    echo " * PL.$1: Callback..."
    echo ' * ...'
    echo '------------------------------------------------------------------------'
}

MENU.DemoPlCheckBoxCb() {
    echo " * PL.$1 Callback..."
    echo " * state.[$2]"

    case $1 in
        Nx-Mode)
            echo ' * ...'
            ;;
        PP-Mode)
            echo ' * ...'
            ;;
    esac

    echo '------------------------------------------------------------------------'
}

# -------------------------------------------------------------------

demo
