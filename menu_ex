#!/bin/sh

# -----------------------------------------------------------------------------
# Customizable console menu to organize different environment settings
#
# Alex Demyankov
# alex.demyankov@gmail.com
# https://www.linkedin.com/in/ademyankov/
#
# March, 2020
#
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# The global variable that holds the menu object
unset MENUEX
declare -A MENUEX=()

# A map that holds all the menus created
MENUEX['map']='declare -A map=()'

# Change to 'Debug' if logs required
MENUEX['build']='Debug'
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
#
# Functions and parameters acronims
#
# [IN]  - input argument
# [OPT] - optional argument
# [OUT] - output result
#
# MENU.Null - is a special string that represents 'no string' for an optional
#             string argument; it can be usefull when an optional string
#             argument is in the middle of the arguments list, For example:
#             "MENU.Create menu1 MENU.Null MENU.Null Menu1Function". In case of
#             "MENU.Create menu1 '' '' Menu1Function" it would be impossible to
#             separate one parameter from the others inside the function
#
# MENU._lover_case - functions, named in such a way, are private and are not
#                    supposed to be called directly, but nothing prevents it
#
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# Pads a string with 'space' chars to the length specified
#
# [IN] string - a string to pad
# [IN] length - the length the output string should be
# [OUT] returns the padded string
#
# -----------------------------------------------------------------------------
MENU._string_pad() {
    local len=$(($2 - ${#1}))
    pad=`printf '%*s' "$len" | tr ' ' " "`
    echo "$1$pad"
}

# -----------------------------------------------------------------------------
# Converts a string to an upper case string
#
# [IN] string - a string to convert
# [OUT] returns the converted string
#
# -----------------------------------------------------------------------------
MENU._to_upper() {
    echo "$(echo ${1} | awk '{print toupper($0)}')"
}

# -----------------------------------------------------------------------------
# Helper functions to display log/trace
#
# [IN] string - a log's mode, supported: {INFO, WARNING, SEVERE}
#
# -----------------------------------------------------------------------------
MENU._log() {
    eval "${MENUEX['styles']}"
    local marker="${styles['green']}${styles['bold']}INFO${styles['reset']}:"
    [[ "$1" == 'WARNING' ]] && marker="${styles['yellow']}${styles['bold']}WARNING${styles['reset']}:"
    [[ "$1" == 'SEVERE' ]] && marker="${styles['red']}${styles['bold']}SEVERE${styles['reset']}:"
    shift
    echo "${FUNCNAME[2]}: $marker $*"
}

MENU._log_info() {
    [[ "${MENUEX["build"]}" == 'Debug' ]] && MENU._log INFO $1
}

MENU._log_warning() {
    [[ "${MENUEX["build"]}" == 'Debug' ]] && MENU._log WARNING $1
}

MENU._error() {
  MENU._log SEVERE $1
}

MENU._warning() {
  MENU._log WARNING $1
}

# -----------------------------------------------------------------------------
# Creates a new menu
#
# [IN]      handle   - a name/handle of the menu to be used w/ the API
# [IN][OPT] name     - a displayed name of the menu
# [IN][OPT] alias    - an alias to be created that displays the menu
# [IN][OPT] callback - a function to be called when the menu is displayed
#
# Remark: The 'alias' parameter creates the alias for the menu unless the alias
#         already exists in the environment
#
# When 'callback' function is called it has 2 arguments passed in:
#
# [IN] handle - the menu's name/handle
# [IN] name   - the menu's name (if specified)
#
# -----------------------------------------------------------------------------
MENU.Create() {
    local ctor="MENU._ctor"
    ${ctor}

    if [[ $# -lt 1 ]]; then
        MENU._error "MENU.Create requires more arguments"
        return
    fi

    local -A context=()
    context['name']='MENU.Null'
    context['alias']='MENU.Null'
    context['callback']='MENU.Null'
    context['tmp.checked']=''       # temporally field used to specify check.button item checked at the context level
    context['selected']=''
    context['item.length.max']=0    # the max char length of an item's name
    context['menu.width']=0         # the length of the longest string in the menu (used for menu's separator)
    context['name']=$2

    MENU._log_info "args: $*"

    [ $# -gt 2 ] && context['alias']=$3
    [ $# -gt 3 ] && context['callback']=$4

    local -a items=()
    context['items']=$(declare -p items)

    eval "${MENUEX['map']}"
    map[$1]=$(declare -p context)
    MENUEX['map']=$(declare -p map)

    eval "${MENUEX["order"]}"
    order[${#order[@]}]=$1
    MENUEX['order']=$(declare -p order)

    local default="MENU.SetStyle $1"
    ${default}

    default="MENU.SetStyleEx $1"
    ${default}

    # Create an alias to display the menu
    if [ "${context['alias']}" != '' ]; then
        if [ `alias | grep "alias ${context['alias']}=" | wc -l` != 0 ]; then
            MENU._warning "Alias '${context['alias']}' already exists in the env and will not be reasigned!"
            [ "${MENUEX['build']}" == "Release" ] && return
        fi
        local argc="$1 ${context['name']} ${context['alias']} ${context['callback']}"
        alias "${context['alias']}"="MENU._show ${argc}"
    fi
}

# The menu's class constructor
MENU._ctor() {
    if [[ ! ${MENUEX['styles']} ]]; then
        # Num  Colour    define          R G B
        # 0    black     COLOR_BLACK     0,0,0
        # 1    red       COLOR_RED       1,0,0
        # 2    green     COLOR_GREEN     0,1,0
        # 3    yellow    COLOR_YELLOW    1,1,0
        # 4    blue      COLOR_BLUE      0,0,1
        # 5    magenta   COLOR_MAGENTA   1,0,1
        # 6    cyan      COLOR_CYAN      0,1,1
        # 7    white     COLOR_WHITE     1,1,1

        local -A styles=()
        styles['black']=`tput setaf 0`
        styles['red']=`tput setaf 1`
        styles['green']=`tput setaf 2`
        styles['yellow']=`tput setaf 3`
        styles['blue']=`tput setaf 4`
        styles['magenta']=`tput setaf 5`
        styles['cyan']=`tput setaf 6`
        styles['white']=`tput setaf 7`

        styles['reset']=`tput sgr0`

        styles['bold']=`tput bold`  # Select bold mode
        styles['dim']=`tput dim`    # Select dim (half-bright) mode
        styles['smul']=`tput smul`  # Enable underline mode
        styles['rmul']=`tput rmul`  # Disable underline mode
        styles['smso']=`tput smso`  # Enter standout (bold) mode
        styles['rmso']=`tput rmso`  # Exit standout mode
        styles['rev']=`tput rev`    # Turn on reverse video mode

        MENUEX['styles']=$(declare -p styles)

        # Calculated width of the entire menu
        MENUEX['width']=0

        # Tracks the order of menus created
        MENUEX['order']='declare -a order=()'
    fi
}

# -----------------------------------------------------------------------------
# Sets the style for the menu
#
# [IN]      handle  - a name/handle of the menu to be used w/ the API
# [IN][OPT] divider - a divider to be used w/ .AddDivider ('|' by default)
#
# [IN][OPT] align   - the menu's items alignment (none by default), supported:
#             by.largest.item - aligns all the menu's items by the length of the
#                               largest item's name
#
# [IN][OPT] color        - the color of the selected item (green by default)
# [IN][OPT] radio.symbol - the symbol for the selected radio.button ('♦' by default)
# [IN][OPT] radio.symbol - the symbol for the cheched check.button ('x' by default)
#
# Remark: 'default' can be passed as any [OPT] argument, which will set the
#         default value for the corresponding style parameter
#
# Example:
#
# > MENU.SetStyle menu1 default default ${red} '○' default
#
# -----------------------------------------------------------------------------
MENU.SetStyle() {
    if [[ $# -lt 1 ]]; then
      MENU._error 'MENU.SetStyle requires more arguments'
      return
    fi

    eval "${MENUEX['map']}"
    eval "${map["$1"]}"

    # By default
    context['divider']='|'
    context['align']='none'
    context['select.color']='green'
    context['radio.button.symbol']='♦'
    context['check.button.symbol']='x'

    # Optional arguments
    [[ $# -gt 1 && "$2" != 'default' ]] && context['divider']=$2
    [[ $# -gt 2 && "$3" != 'default' ]] && context['align']=$3
    [[ $# -gt 3 && "$4" != 'default' ]] && context['select.color']=$4
    [[ $# -gt 4 && "$5" != 'default' ]] && context['radio.button.symbol']=$5
    [[ $# -gt 5 && "$6" != 'default' ]] && context['check.button.symbol']=$6

    # In case of a complex alignment the menu's width needs to be calculated when shown
    #[[ "${context['align']}" == 'by.largest.item' ]] && context['menu.width']=0

    map[$1]=$(declare -p context)
    MENUEX['map']=$(declare -p map)
}

# -----------------------------------------------------------------------------
# Set the extra style of the menu (replace the default style)
#
# 1 [IN]      handle             - a name/handle of the menu
# 2 [IN][OPT] separator.show     - {true/false} whether to print the menu's
#                                  separator (true by default)
# 3 [IN][OPT] separator.symbol   - separator symbol ('-' by default)
# 4 [IN][OPT] name.header        - menu's name header (' * ' by default)
# 5 [IN][OPT] name.footer        - menu's name footer (':' by default)
# 6 [IN][OPT] radio.button.bracket.start - radio.button opening symbol ('(' by default)
# 7 [IN][OPT] radio.button.bracket.end   - radio.button closing symbol (')' by default)
# 8 [IN][OPT] check.button.bracket.start - check.button opening symbol ('[' by default)
# 9 [IN][OPT] check.button.bracket.end   - check.button closing symbol (']' by default)
#
# Remark: 'default' can be used to specify the default argument
#
# -----------------------------------------------------------------------------
MENU.SetStyleEx() {
    if [[ $# -lt 1 ]]; then
      MENU._error 'MENU.SetStyle requires more arguments'
      return
    fi

    eval "${MENUEX['map']}"
    eval "${map["$1"]}"

    # By default
    context['separator.show']='true'
    context['separator.symbol']='-'
    context['name.header']=' * '
    context['name.footer']=':'
    context['radio.button.bracket.start']='('
    context['radio.button.bracket.end']=')'
    context['check.button.bracket.start']='['
    context['check.button.bracket.end']=']'

    # Optional arguments
    [[ $# -gt 1 && "$2" != 'default' ]] && context['separator.show']=$2
    [[ $# -gt 2 && "$3" != 'default' ]] && context['separator.symbol']=$3
    [[ $# -gt 3 && "$4" != 'default' ]] && context['name.header']=$4
    [[ $# -gt 4 && "$5" != 'default' ]] && context['name.footer']=$5
    [[ $# -gt 5 && "$6" != 'default' ]] && context['radio.button.bracket.start']=$6
    [[ $# -gt 6 && "$7" != 'default' ]] && context['radio.button.bracket.end']=$7
    [[ $# -gt 7 && "$8" != 'default' ]] && context['check.button.bracket.start']=$8
    [[ $# -gt 8 && "$9" != 'default' ]] && context['check.button.bracket.end']=$9

    #if [ "${context['name']}" != 'MENU.Null' ]; then
    #    local length=${#context['name']}
    #    ((length += ${#context['name.header']}))
    #    ((length += ${#context['name.footer']}))
    #    ((length += 1)) # one space ' ' after the menu's name
    #    context['menu.width']=$length
    #fi

    map[$1]=$(declare -p context)
    MENUEX['map']=$(declare -p map)
}

# -----------------------------------------------------------------------------
# [IN] type - the type of an item to be added, supported types:
#       {radio.button, check.button, divider, ln.break}
#
# [IN] $* - the rest of arguments comes from the public .Add function
#
# -----------------------------------------------------------------------------
MENU._add_item() {
    if [[ $# -lt 2 ]]; then
        MENU._error "MENU.AddItem requires more arguments"
        return
    fi

    MENU._log_info "args: $*"

    eval item_name="$3"

    local -A item=()
    item['type']=$1
    item['name']=$item_name
    item['checked']='off' # used for 'check.button' items only
    item['alias']='MENU.Null'
    item['callback']='MENU.Null'

    # Optional arguments
    [ $# -gt 3 ] && item['alias']=$4
    [ $# -gt 4 ] && item['callback']=$5

    eval "${MENUEX['map']}"
    eval "${map["$2"]}"
    eval "${context['items']}"

    items[${#items[@]}]=$(declare -p item)
    context['items']=$(declare -p items)

    # Used for 'by.largest.item' alignment since we need to know what item's length is the longest one
    [[ ${context['item.length.max']} -lt ${#item['name']} ]] && context['item.length.max']=${#item['name']}

    # Calculate the width of the menu only if it's a simple alignment mode;
    # because in case of 'by-largest' alignment we cannot accuratelly calculate
    # the width until all the items have been added into the menu
    #if [ "${context['align']}" != 'by.largest.item' ]; then
    #    local item_width=${#item['name']}
    #    if [[ "${item['type']}" == 'divider' ]]; then
    #        ((item_width += ${#context['divider']}))
    #    elif [[ "${item['type']}" == 'check.button' || "${item['type']}" == 'radio.button' ]]; then
    #        ((item_width += 4)) # '[ ] '
    #    fi
    #    ((item_width += 1)) # ' ' after each item's name
    #    ((context['menu.width']+=$item_width))
    #else
    #    # Will trigger to re-calculate again the menu's width in case an item is added
    #    # after the 'menu.width' was calculated the first time
    #    context['menu.width']=0
    #fi

    #[[ ${context['menu.width']} -gt ${MENUEX['width']} ]] && MENUEX['width']=${context['menu.width']}

    map[$2]=$(declare -p context)
    MENUEX['map']=$(declare -p map)

    [[ "${item['type']}" != 'radio.button' && "${item['type']}" != 'check.button' ]] && return

    # Create an alias to call the menu's callback
    if [[ "${item['alias']}" != 'MENU.Null' ]] && [[ "${item['callback']}" != '' ]]; then
        if [ `alias | grep "alias ${item['alias']}=" | wc -l` != 0 ]; then
            MENU._warning "Alias '${item['alias']}' already exists in the env and will not be reasigned!"
            [[ "${MENUEX['build']}" == 'Release' ]] && return
        fi

        # See Select command for the flags:                       show   1    2   mode
        [[ "${item['type']}" == 'radio.button' ]] && local flags='true false true false' || local flags='true false false current'
        alias "${item['alias']}"="MENU._select $2 \"${item['name']}\" $flags"
    fi
}

# -----------------------------------------------------------------------------
# Add a item into a menu
#
# [IN]      handle   - a handle of the menu
# [IN]      name     - a name of an item to be added into the menu
# [IN][OPT] alias    - an alias to be created that selects the item
# [IN][OPT] callback - a function to be called when the item is selected
#
# Remark: The 'alias' parameter creates the alias for the item unless the alias
#         already exists in the environment; If 'alias' is part of the name,
#         for example item item = 'MyItem1' alias = 'em1', then the alias 'em1'
#         will be hightlighted (underlined) when displayed.
#
# Remark: When the item's 'callback' is called there are 2 arguments passed
#         into the callbak: [IN] name - the menu name and [IN] item - the
#         selected item name;
#
# Remark: When 'callback' function is called it has 3 arguments passed in:
#
# [IN]      handle - the menu's name/handle
# [IN]      name   - the name of the selected item
# [IN][OPT] state  - {on, off} item's state (check.button type only)
#
# Example:
#
# > MENU.AddRadioButton MyMenu1 Item1 m1 Menu1Item1_Cb
# > MENU.AddRadioButton MyMenu1 Item2 m2 Menu1Item2_Cb
#
# -----------------------------------------------------------------------------
MENU.AddRadioButton() {
    # A trick to pass an item's name string as a variable to be able
    # to use spaces in the name string, e.g. "Menu Item 1"
    local menu_name=$1
    local item_name="$2"
    shift 2
    local cmd="MENU._add_item radio.button $menu_name \"\${item_name}\" $*"
    ${cmd}
}

MENU.AddCheckButton() {
    local menu_name=$1
    local item_name="$2"
    shift 2
    local cmd="MENU._add_item check.button $menu_name \"\${item_name}\" $*"
    ${cmd}
}

MENU.AddLnBreak() {
    local cmd="MENU._add_item ln.break $*"
    ${cmd}
}

MENU.AddLabel() {
    local menu_name=$1
    local item_name="$2"
    shift 2
    local cmd="MENU._add_item label $menu_name \"\${item_name}\" $*"
    ${cmd}
}

MENU.AddDivider() {
    local cmd="MENU._add_item divider $*"
    ${cmd}
}

# -----------------------------------------------------------------------------
# Selects an item in the menu
#
# [IN]      arg1  - name of the menu
# [IN]      arg2  - name of the item to be selected
#
# The rest of the arguments are 'false' by default:
#
# [IN][OPT] show  - {true/false} whether to call MENU.Show
# [IN][OPT] flag1 - {true/false} whether to call the main manu's callback
# [IN][OPT] flag2 - {true/false} whether to call the selected item's callback
# [IN][OPT] mode  - call-mode of all the check button item's callbacks
#
# DEMO: For example, the following command selects 'Release' radio.button in
#       the demo 'Build' menu, shows the 'Build' menu, and calls the 'Release'
#       radio.button's callbacks:
#
# > MENU.Select build_menu Release true false true fals
#
# -----------------------------------------------------------------------------
MENU.Select() {
    if [[ $# -lt 2 ]]; then
        MENU._error 'MENU.Select requires more arguments'
        return
    fi

    eval "${MENUEX['map']}"
    eval "${map["$1"]}"

    [[ $# -gt 2 ]] && flagX=$3 || flagX='false'

    # We have to go through items[] first to check whether
    # the selected item is a check button type item
    eval "${context['items']}"
    local check_button_set
    for i in "${!items[@]}"; do
        eval "${items["$i"]}"
        if [[ "${item['name']}" == $2 ]] && [[ "${item['type']}" == 'check.button' ]]; then
            [[ "${item['checked']}" == 'on' ]] && item['checked']='off' || item['checked']='on'
            items["$i"]=$(declare -p item)
            context['items']=$(declare -p items)

            [ "$flagX" == 'true' ] && context['tmp.checked']=$2
            MENU._log_info "CHECK BOX: '$2' state='${item['checked']}'"

            check_button_set='true'
            break
        fi
    done

    # Set selected if the itme's type is the radio.button
    [[ ! "$check_button_set" ]] && context['selected']=$2

    map[$1]=$(declare -p context)
    MENUEX['map']=$(declare -p map)

    MENU._log_info "ARGS: $*"

    [[ $# -gt 3 ]] && flag1=$4 || flag1='false'
    [[ $# -gt 4 ]] && flag2=$5 || flag2='false'
    [[ $# -gt 5 ]] && mode=$6 || mode='false'

    # When called from an alias of an item there is an optional extra argument
    # true/false whether to call the main menu's callback in addition
    [[ $# -gt 6 ]] && flag1=$7

    if [ "$flagX" == 'true' ]; then
        MENU._log_info "Show $1 f1=$flag1 f2=$flag2 mode=$mode"
        MENU.Show $1 $flag1 $flag2 $mode
    fi
}

# arguments are comming from the item's alias: $*
MENU._select() {
    MENU._log_info "ARGS: $*"

    [[ $# -gt 3 ]] && f1=$4 || f1='false'
    [[ $# -gt 4 ]] && f2=$5 || f2='false'
    [[ $# -gt 5 ]] && mode=$6 || mode='false'

    # an extra {true/false} might come from an alias argument
    # to call the main menu's callback
    [[ $# -gt 6 ]] && f1=$7

    MENU.Select $1 "$2"

    if [ $# -gt 2 ] && [ "$3" == 'true' ]; then
        MENU._separator $1
        MENU.Show $1 $f1 $f2 $mode
        MENU._separator $1
    fi
}

# -----------------------------------------------------------------------------
# Performs an operation for all the check.button items in the menu
#
# [IN] name - a name/handle of the menu
# [IN] operation - a type of operation to perform on all the check.buttons:
#       check   - check all the check.button items
#       uncheck - un-check all the check.button itmes
#       flip    - flip the state of all the check.button itmes
#
# The rest of the arguments are 'false' by default:
#
# [IN][OPT] show  - {true/false} whether to call MENU.Show
# [IN][OPT] flag1 - {true/false} whether to call the main manu's callback
# [IN][OPT] flag2 - {true/false} whether to call the selected item's callback
# [IN][OPT] mode  - call-mode of all the check.button item's callbacks
#
# DEMO: For example, the following command flips all the check.buttons in the
#       demo 'Build' menu, shows the 'Build' menu, and calls all the checked
#       check.button's callbacks:
#
# > MENU.CheckButtonForAll build_menu flip true false false checked
#
# -----------------------------------------------------------------------------
MENU.CheckButtonForAll() {
    if [ $# -lt 2 ]; then
        MENU._error "MENU.CheckButtonForAll requires more arguments"
        return
    fi

    MENU._log_info "ARGS: $*"

    eval "${MENUEX['map']}"
    eval "${map["$1"]}"
    eval "${context['items']}"

    local changed='false'
    for i in "${!items[@]}"; do
        eval "${items["$i"]}"

        [ "${item['type']}" != 'check.button' ] && continue;

        local updated='false'
        case $2 in
            check)
                [ "${item["checked"]}" == 'off' ] && item['checked']='on'; updated='true'
                ;;
            uncheck)
                [ "${item["checked"]}" == 'on' ] && item['checked']='off'; updated='true'
                ;;
            flip)
                [ "${item["checked"]}" == 'on' ] && item['checked']='off' || item['checked']='on'
                updated='true'
                ;;
        esac
        [ "$updated" == 'true' ] && items["$i"]=$(declare -p item); context['items']=$(declare -p items); changed='true'
    done

    if [[ "$changed" == 'true' ]]; then
        map[$1]=$(declare -p context)
        MENUEX['map']=$(declare -p map)
    fi

    [[ $# -gt 2 ]] && show=$3 || show='false'
    [[ $# -gt 3 ]] && flag1=$4 || flag1='false'
    [[ $# -gt 4 ]] && flag2=$5 || flag1='false'
    [[ $# -gt 5 ]] && mode=$6 || mode='false'

    if [ "$show" == 'true' ]; then
        MENU.Show $1 $flag1 $flag2 $mode
    fi
}

# -----------------------------------------------------------------------------
# Displays the menu
#
# [IN] name - a name/handle of the menu
#
# The rest of the arguments are 'false' by default:
#
# [IN][OPT] flag1 - {true/false} whether to call the main manu's callback
# [IN][OPT] flag2 - {true/false} whether to call the selected item's callback
# [IN][OPT] mode  - call-mode of all the check button item's callbacks:
#            no (false)   - do not call any callback for any item
#            all (true)   - call all the callbacks for all check.button items
#                           regardless of its state
#            current      - call the callback of the check.button items that
#                           changes the state (.Select command only)
#            checked      - call all the callbacks for all checked check.buttons
#            unchecked    - call all the callbacks for all un-checked
#                           check.buttons
#
# DEMO: For example, the following command simply shows/displays the demo
#       'PLATFORM' menu w/o calling any callbacks:
#
# > MENU.Show pl_menu false false false
#
# -----------------------------------------------------------------------------
MENU.Show() {
    if [ $# -lt 1 ]; then
        MENU._error 'MENU.Show requires more arguments'
        return
    fi

    MENU._log_info "ARGS: $*"

    eval "${MENUEX['map']}"
    eval "${MENUEX['styles']}"
    eval "${map["$1"]}"
    eval "${context['items']}"

    if [ "${context['name']}" != 'MENU.Null' ]; then
        printf "${context['name.header']}${context['name']/${context['alias']}/${styles['smul']}${context['alias']}${styles['reset']}}${context['name.footer']} "
    fi

    local idx=0
    local -a callbacks=()
    local -a arguments=()

    # Store the main menu's callback to be called later
    if [ "$2" == 'true' ] && [ "${context['callback']}" != 'MENU.Null' ]; then
        callbacks[$idx]=${context['callback']}
        [[ "${context['name']}" != 'MENU.Null' ]] && arguments[$idx]+="$1 ${context['name']}" || arguments[$idx]="$1"
        idx=$(($idx + 1))
    fi

    for i in "${!items[@]}"; do
        eval "${items["$i"]}"

        local name=${item['name']}

        if [ "${context['align']}" == 'by.largest.item' ]; then
            name=$(MENU._string_pad ${item['name']} ${context['item.length.max']})
        fi

        local type=${item['type']}

        if [ "$type" == 'ln.break' ]; then
            printf '\n'
            if [ "${context['name']}" != 'MENU.Null' ]; then
                local width=${#context['name']}
                ((width += ${#context['name.header']}))
                ((width += ${#context['name.footer']}))
                ((width += 1))
                local pad=$(MENU._string_pad '' $width)
                printf "$pad"
            fi
            continue
        fi

        if [ "$type" == 'divider' ]; then
            local divider=${context['divider']}
            printf "$divider "
            continue;
        fi

        if [ "$type" == 'label' ]; then
            printf "$name "
            continue;
        fi

        local alias=${item['alias']}
        local color_ref=${context['select.color']}
        local color=${styles["$color_ref"]}
        local selected=${context['selected']}

        if [ "$type" == 'radio.button' ]; then
            if [ "${item['name']}" == "$selected" ]; then
                local hi=${styles['smul']}${item['alias']}${styles['rmul']}
                printf "${color}${styles['bold']}${context['radio.button.bracket.start']}${context['radio.button.symbol']}${context['radio.button.bracket.end']} ${name/$alias/$hi}${styles['reset']} "

                # Store the radio button item's callback to be called later
                if [ "$3" == 'true' ] && [ "${item['callback']}" != 'MENU.Null' ]; then
                    callbacks[$idx]=${item['callback']}
                    arguments[$idx]="$1 ${item['name']}"
                    idx=$(($idx + 1))
                fi
            else
                printf "${context['radio.button.bracket.start']} ${context['radio.button.bracket.end']} ${name/$alias/${styles['smul']}$alias${styles['reset']}} "
            fi
            continue;
        fi

        if [ "$type" == 'check.button' ]; then
            local mode=$4
            if [ "${item['checked']}" == 'on' ]; then
                local hi=${styles['smul']}${item['alias']}${styles['rmul']}
                printf "${color}${styles['bold']}${context['check.button.bracket.start']}${context['check.button.symbol']}${context['check.button.bracket.end']} ${name/$alias/$hi}${styles['reset']} "
                if [ "$mode" == 'checked' ] && [ "${context['callback']}" != 'MENU.Null' ]; then
                    callbacks[$idx]=${item['callback']}
                    arguments[$idx]="$1 ${item['name']} ${item['checked']}"
                    idx=$(($idx + 1))
                fi
            else
                printf "${context['check.button.bracket.start']} ${context['check.button.bracket.end']} ${name/$alias/${styles['smul']}$alias${styles['reset']}} "
                if [ "$mode" == 'unchecked' ] && [ "${context['callback']}" != 'MENU.Null' ]; then
                    callbacks[$idx]=${item['callback']}
                    arguments[$idx]="$1 ${item['name']} ${item['checked']}"
                    idx=$(($idx + 1))
                fi
            fi

            if [ "${context['tmp.checked']}" == "${item['name']}" ] && [ "$mode" == 'current' ] && [ "${context['callback']}" != 'MENU.Null' ]; then
                callbacks[$idx]=${item['callback']}
                arguments[$idx]="$1 ${item['name']} ${item['checked']}"
                idx=$(($idx + 1))

                MENU._log_warning "mode: $mode context[checked]: ${context['tmp.checked']}"
                MENU._log_warning "${item['callback']} ${item['name']} ${item['checked']}"

                context['tmp.checked']=''

                map[$1]=$(declare -p context)
                MENUEX['map']=$(declare -p map)
            fi

            # Store all the check button item's callbacks to be called later
            if [ "$mode" == 'all' ] || [ "$mode" == 'true' ] && [ "${context['callback']}" != 'MENU.Null' ]; then
                callbacks[$idx]=${item['callback']}
                arguments[$idx]="$1 ${item['name']} ${item['checked']}"
                idx=$(($idx + 1))
            fi

            continue;
        fi
    done

    printf '\n'

    # Last, call all the callbacks with its arguments that needs to be called
    for i in "${!callbacks[@]}"; do
        cb=${callbacks[$i]}
        [[ "${arguments[$i]}" ]] && cb+=" ${arguments[$i]}"
        ${cb}
    done
}

# -----------------------------------------------------------------------------
# Displays all the menus created
#
# All the optional arguments are 'false' by default:
#
# [IN][OPT] order - {true/false} whether to display all the menus in the order
#           of how the menus were created
# [IN][OPT] flag1 - {true/false} whether to call the main manu's callback
# [IN][OPT] flag2 - {true/false} whether to call the selected item's callback
# [IN][OPT] mode  - call-mode of all the check.button item's callbacks
#
# Remark: By default, the displaying order of the menus corresponds to the
#         order of how the keys of the bash's assosiative array are sorted
#
# -----------------------------------------------------------------------------
MENU.ShowAll() {
    [[ $# -gt 0 ]] && order=$1 || order='false'
    [[ $# -gt 1 ]] && f1=$2 || f1='false'
    [[ $# -gt 2 ]] && f2=$3 || f2='false'
    [[ $# -gt 3 ]] && mode=$4 || mode='false'

    local last_menu=''
    if [ "$order" == 'true' ]; then
        eval "${MENUEX['order']}"
        for i in "${!order[@]}"; do
            last_menu=${order[$i]}
            MENU._separator $last_menu true
            MENU.Show $last_menu $f1 $f2 $mode
        done
    else
        eval "${MENUEX['map']}"
        for menu in "${!map[@]}"; do
            eval "${map["$menu"]}"
            last_menu=$menu
            MENU._separator $menu true
            MENU.Show $menu $f1 $f2 $mode
        done
    fi
    MENU._separator $last_menu true
}

# -----------------------------------------------------------------------------
# It's quite tricky to calculate accuratelly the menu's length because of such
# factors as ln.break, alignment, and customizable chars for the radio/check
# buttons
#
# [IN]  name   - the menu's handle
# [OUT] length - the length of the menu
#
# -----------------------------------------------------------------------------
MENU._calculate_menu_width() {
    if [ $# -lt 1 ]; then
        MENU._error 'MENU._calculate_menu_width requires more arguments'
        return
    fi

    eval "${MENUEX['map']}"
    eval "${map["$1"]}"
    eval "${context['items']}"

    local max=0
    local length=0

    for i in "${!items[@]}"; do
        eval "${items["$i"]}"

        local item_length=0
        case ${item['type']} in
            check.button | radio.button)
                [ "${context['align']}" == "by.largest.item" ] && ((item_length += ${context['item.length.max']})) || ((item_length += ${#item['name']}))
                ((item_length += ${#context["${item['type']}.bracket.start"]}))
                ((item_length += ${#context["${item['type']}.bracket.end"]}))
                ((item_length += ${#context["${item['type']}.symbol"]}))
                ((item_length += 1))
                ;;
            divider)
                ((item_length += ${#context['divider']}))
                ;;
            label)
                ((item_length += ${#item['name']}))
                ;;
            ln.break)
                [ $length -gt $max ] && max=$length
                length=0
                continue
                ;;
        esac

        ((item_length += 1)) # one space ' ' after each item's name
        ((length += $item_length))
    done

    [ $length -gt $max ] && max=$length

    local width=0
    [ $max -gt 0 ] && width=$max || width=$length

    if [[ "${context['name']}" != 'MENU.Null' ]]; then
        ((width += ${#context['name']}))
        ((width += ${#context['name.header']}))
        ((width += ${#context['name.footer']}))
        ((width += 1)) # one space ' ' after the menu's name
    fi

    echo $width
}

# -----------------------------------------------------------------------------
# Prints out the menus' separator
#
# [IN]      menu    - the menu's handle
# [IN][OPT] largest - {true/false} whether to use the largest length
#                     of all the menus
#
# -----------------------------------------------------------------------------
MENU._separator() {
    if [ $# -lt 1 ]; then
        MENU._error 'MENU._separator requires more arguments'
        return
    fi

    eval "${MENUEX['map']}"
    eval "${map["$1"]}"

    local width=${context['menu.width']}

    if [[ $width -lt 1 ]]; then
        width=$(MENU._calculate_menu_width $1)
        [[ $width -gt ${MENUEX['width']} ]] && MENUEX['width']=$width

        MENU._log_warning "re-calc the width: $width"

        context['menu.width']=$width

        map[$1]=$(declare -p context)
        MENUEX['map']=$(declare -p map)
    fi

    [[ $# -gt 1 && "$2" == 'true' ]] && width=${MENUEX['width']}

    if [ "${context['separator.show']}" == 'true' ]; then
        ((width--)) # compensation because printf already prints out one 'separator' symbol
        cmd="printf -- '${context['separator.symbol']}%.0s' {1..$width}"
        eval $cmd
        echo ""
    fi
}

# arguments are comming from the main menu's alias: $* f1 f2 mode
MENU._show() {
    [[ $# -gt 4 ]] && f1=$5 || f1='false'
    [[ $# -gt 5 ]] && f2=$6 || f2='false'
    [[ $# -gt 6 ]] && mode=$7 || mode='false'

    MENU._separator $1
    MENU.Show $1 $f1 $f2 $mode
    MENU._separator $1
}

MENU._debug_print() {
    eval "${map["$1"]}"
    eval "${MENUEX['styles']}"

    echo "* $1:"
    for ctx_key in "${!context[@]}"; do
        if [ "$ctx_key" == 'items' ]; then
            echo "  - [$ctx_key]:"
            eval "${context["$ctx_key"]}"
            for items_key in "${!items[@]}"; do
                echo "    + [$items_key]: ${items["$items_key"]}"
                eval "${items["$items_key"]}"
                for indx in "${!item[@]}"; do
                    printf "      ♦ [$indx]: ${item["$indx"]}\n"
                done
            done
        else
            printf "  - [$ctx_key]: ${context["$ctx_key"]}${styles['reset']}\n"
        fi
    done
}

MENU._debug_print_all() {
    [[ "${MENUEX['build']}" == 'Release' ]] && return

    eval "${MENUEX['map']}"
    for key in "${!map[@]}"; do
        MENU._debug_print $key
    done
}

# ---------------------------------------------------------------------------------------------------------------------
#
# Demo Example
#
# ---------------------------------------------------------------------------------------------------------------------

MENU.CreateDemo() {
    null='MENU.Null'

    #
    # Demo menu 'PLATFORM'
    #

    # -----------------------------------------------------------------------------------------------------------------
    # Create a menu
    #
    # 1           handle                     - a name/handle of the menu to be used w/ the API
    # 2 [OPT]       |     name               - a displayed name of the menu
    # 3 [OPT]       |      |    alias        - an alias to be created that displays the menu
    # 4 [OPT]       |      |     |  callback - a function to be called when the menu is displayed
    MENU.Create pl_menu PLATFORM PL MENU.DemoMainMenu
    #MENU.Create pl_menu $null PL MENU.DemoMainMenu
    #MENU.Create pl_menu $null $null MENU.DemoMainMenu
    #MENU.Create pl_menu

    # -----------------------------------------------------------------------------------------------------------------
    # Under the hood 'PL' is just an alias for: 'MENU.Show pl_menu'
    #
    # 1 [OPT]  flag1           - whether to call the main menu's callback
    # 2 [OPT]   |    flag2     - whether to call the selected radio button item's callback
    # 3 [OPT]   |     |   mode - call-mode of all the check button item's callbacks, for modes see documentation for .Show
    # > PL    false false all
    #
    # 'PL' alias usage examples:
    # > PL                 - displays the menu
    # > PL true            - displays the menu + calls the menu's callback
    # > PL false true      - displays the menu + calls the selected radio button item's callback
    # > PL true true       - displays the menu + calls both the selected item and the main menu's callbacks
    # > PL false false all - displays the menu + calls all the radio button item's callbacks
    # -----------------------------------------------------------------------------------------------------------------

    # -----------------------------------------------------------------------------------------------------------------
    # Set the menu's style (replace the default style)
    #
    # 1           handle                                               - a name/handle of the menu to be used w/ the API
    # 2 [OPT]       |    divider                                       - devider to be used w/ .AddDivider ('|' by default)
    # 3 [OPT]       |      |        alignment                          - alignent of the item names (none by default)
    # 4 [OPT]       |      |           |          color                - the color of hightlighted items (green by default)
    # 5 [OPT]       |      |           |            |    symbol1       - the select symbol for the radio button when selected
    # 6 [OPT]       |      |           |            |      |   symbol2 - the check symbol for the check button when checked
    #MENU.SetStyle pl_menu default by.largest.item ${red} '○' default
    #MENU.SetStyle pl_menu default by.largest.item
    # -----------------------------------------------------------------------------------------------------------------

    # -----------------------------------------------------------------------------------------------------------------
    # Set the extra style of the menu (replace the default style)
    # 1            handle                                                  - a name/handle of the menu to be used w/ the API
    # 2 [OPT]         |     separator.show                                 - {true/false} whether to print the menu's separator (true by default)
    # 3 [OPT]         |       |  separator.symbol                          - separator symbol ('-' by default)
    # 4 [OPT]         |       |    |  name.header                          - menu's name header (' * ' by default)
    # 5 [OPT]         |       |    |    |  name.footer                     - menu's name footer (':' by default)
    # 6 [OPT]         |       |    |    |    | symbol.radio.start          - radio.button opening symbol ('(' by default)
    # 7 [OPT]         |       |    |    |    |   | symbol.radio.end        - radio.button closing symbol (')' by default)
    # 8 [OPT]         |       |    |    |    |   |   | symbol.chk.start    - check.button opening symbol ('[' by default)
    # 9 [OPT]         |       |    |    |    |   |   |   |  symbol.chk.end - check.button closing symbol (']' by default)
    #MENU.SetStyleEx pl_menu true '-' " * " ":" '(' ')' '[' ']'
    #
    # For example you want to create a menu that looks like this:
    #  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #  => MENU - / / Item1 /*/ Item2 / / Item3 | | chk1 |+| chk2
    #  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #
    #MENU.SetStyleEx pl_menu true '~' "=>" " -" '/' '/' '|' '|'
    #MENU.SetStyle pl_menu default default ${red} '*' '+'
    # -----------------------------------------------------------------------------------------------------------------

    # -----------------------------------------------------------------------------------------------------------------
    # Add a radio.button item into the menu
    #
    # 1               handle                    - a name/handle of the menu to be used w/ the API
    # 2                 |    name               - an item's name to be added into the menu
    # 3 [OPT]           |     |    alias        - an alias to be created that triggers the item's callback
    # 4 [OPT]           |     |     |  callback - a function to be called when an item is selected
    MENU.AddRadioButton pl_menu Linux nux MENU.DemoPlLinuxCb
    #MENU.AddRadioButton pl_menu Linux $null MENU.DemoPlLinuxCb
    #MENU.AddRadioButton pl_menu Linux
    #
    # In the invocation example #2, there is no alias for item 'Linux', so the only way to call it is by using
    # the .Select command, like so: MENU.Select pl_menu Linux true false true
    # Please, look into .Select command demo to understand all the flags
    #
    # -----------------------------------------------------------------------------------------------------------------
    # Under the hood 'nux' is just an alias for: 'MENU.Select pl_menu Linux true false true'
    #
    # 1 [OPT]  flag1     - whether to call the main menu's callback
    # 2 [OPT]   |   mode - call-mode of the check button callbacks [no (false), all (true), checked, unchecked]
    # > nux    true no
    #
    # 'nux' alias usage examples:
    # > nux          - selects 'Linux' item, displays the 'PLATFORM' menu and triggers the 'Linux' item's callback
    # > nux true     - all the above + triggers the 'PLATFORM' menu's callback
    # > nux true all - all the above + triggers all the check button item's callbacks (if any)
    # -----------------------------------------------------------------------------------------------------------------

    MENU.AddRadioButton pl_menu rpi3 pi3 MENU.DemoPlRpi3Cb
    MENU.AddDivider pl_menu
    #MENU.AddLnBreak pl_menu
    MENU.AddLabel pl_menu QEMU:
    MENU.AddRadioButton pl_menu v8 v8 MENU.DemoPlQemuCb
    MENU.AddRadioButton pl_menu arm32 arm MENU.DemoPlQemuCb
    MENU.AddDivider pl_menu
    MENU.AddRadioButton pl_menu "Name w/ space" ace MENU.DemoPlQemuCb

    # -----------------------------------------------------------------------------------------------------------------
    # Select an item of the menu
    #
    #           handle                             - a name/handle of the menu to be used w/ the API
    #             |    name                        - a name of an item to be set as 'selected' in the menu
    #             |     |   show                   -
    #             |     |    |    flag1            -
    #             |     |    |     |    flag2      -
    #             |     |    |     |     |    mode -
    MENU.Select pl_menu rpi3 false false true no
    # -----------------------------------------------------------------------------------------------------------------

    # -----------------------------------------------------------------------------------------------------------------
    # Show/display the menu
    #
    #           handle                - a name/handle of the menu to be used w/ the API
    #             |   flag1           - whether to call the main menu's callback
    #             |     |  flag2      - whether to call the selected radio button item's callback
    #             |     |    |   mode - call mode of the check button callbacks [no (false), all (true), checked, unchecked]
    #MENU.Show pl_menu true true all

    #
    # mode:
    #  no (false)   - do not call any callback for any check button itmes
    #  all (true)   - call all the callbacks for all check button items regardless of the state
    #  current      - call the callback of the check button item that changes the state (.Select only)
    #  checked      - call all the callbacks for all checked check button items
    #  unchecked    - call all the callbacks for all un-checked check button items
    #
    # -----------------------------------------------------------------------------------------------------------------

    MENU.Create build_menu Build Build MENU.DemoMainMenu

    #
    # if there is no alias for the menu you can call it through
    # MENU API directly or create your own alias:
    #
    # > MENU.Show build_menu
    #

    #
    # Demo menu 'Build'
    #
    MENU.AddRadioButton build_menu Debug dbg MENU.DemoBuildChange
    MENU.AddRadioButton build_menu Release rls MENU.DemoBuildChange
    MENU.AddDivider build_menu
    MENU.AddCheckButton build_menu Pedantic Pedant MENU.DemoBuildGccFlags
    MENU.AddCheckButton build_menu Wall all MENU.DemoBuildGccFlags
    MENU.AddCheckButton build_menu Werror err MENU.DemoBuildGccFlags
    MENU.AddCheckButton build_menu fPIC PIC MENU.DemoBuildGccFlags
    MENU.AddCheckButton build_menu isoC99 iso MENU.DemoBuildGccFlags
    MENU.Select build_menu Debug false
    MENU.Select build_menu Wall false
    MENU.Select build_menu Werror false
    #MENU.Show build_menu true true all

    #
    # Demo menu 'LOGS'
    #
    MENU.Create logs_menu $null LOGS MENU.DemoMainMenu
    MENU.SetStyle logs_menu default by.largest.item

    MENU.AddRadioButton logs_menu FATAL $null MENU.DemoLogsCb
    MENU.AddRadioButton logs_menu SEVERE $null MENU.DemoLogsCb
    MENU.AddRadioButton logs_menu INFO $null MENU.DemoLogsCb
    MENU.AddRadioButton logs_menu OFF $null MENU.DemoLogsCb
    #MENU.AddLnBreak logs_menu
    MENU.AddRadioButton logs_menu FINE $null MENU.DemoLogsCb
    MENU.AddRadioButton logs_menu FINER $null MENU.DemoLogsCb
    MENU.AddRadioButton logs_menu FINEST $null MENU.DemoLogsCb
    MENU.AddRadioButton logs_menu WARNING $null MENU.DemoLogsCb


    MENU.Select logs_menu INFO false
    #MENU.Show logs_menu true true

    MENU._debug_print_all
}

# -----------------------------------------------------------------------------------------------------------------
# The Demo Menu's Callbacks
# -----------------------------------------------------------------------------------------------------------------

# [IN] handle - the menu's name/handle
# [IN] name   - the menu's name (if specified)
MENU.DemoMainMenu() {
    MENU._separator $1
    echo " $2.Callback..."
    echo ' ...'
}

# [IN]      handle - the menu's name/handle
# [IN]      name   - the name of the selected item
# [IN][OPT] state  - {on, off} item's state (check.button type only)
MENU.DemoPlQemuCb() {
    MENU._separator $1
    echo " PL.Qemu.$2.Callback..."
    echo ' ...'
}

MENU.DemoPlLinuxCb() {
    if [[ "$2" != 'Linux' ]]; then
        MENU._error "Wrong callback!"
        return
    fi
    MENU._separator $1
    echo " PL.Linux.Callback..."
    echo ' ...'
}

MENU.DemoPlRpi3Cb() {
    MENU._separator $1
    echo " PL.$2.Callback..."
    echo ' ...'
}

MENU.DemoBuildChange() {
    MENU._separator $1
    echo " Build.$2.Callback..."

    case $2 in
        Debug)
            echo ' ...'
            ;;
        Release)
            echo ' ...'
            ;;
    esac

}

MENU.DemoBuildGccFlags() {
    MENU._separator $1
    echo " PL.$2.state.[$3].Callback..."

    case $2 in
        Pedantic)
            echo ' ...'
            ;;
        Wall)
            echo ' ...'
            ;;
        Werror)
            echo ' ...'
            ;;
        fPIC)
            echo ' ...'
            ;;
        isoC99)
            echo ' ...'
            ;;
    esac

}

MENU.DemoLogsCb() {
    MENU._separator $1
    echo " LOGS.$2.Callback..."

    case $2 in
        FATAL)
            echo ' ...'
            ;;
        SEVERE)
            echo ' ...'
            ;;
        WARNING)
            echo ' ...'
            ;;
        INFO)
            echo ' ...'
            ;;
        FINE)
            echo ' ...'
            ;;
        FINER)
            echo ' ...'
            ;;
        FINEST)
            echo ' ...'
            ;;
        OFF)
            echo ' ...'
            ;;
    esac
}

# -----------------------------------------------------------------------------------------------------------------

MENU.CreateDemo
alias dev='MENU.ShowAll true'

# run 'dev' alias to see all the demo menus
dev
