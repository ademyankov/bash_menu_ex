#!/bin/bash

# -----------------------------------------------------------------------------
# Customizable console menu to organize different environment settings
#
# Copyright(c) 2020 Alex Demyankov <alex.demyankov@gmail.com>
# All rights reserved.
#
# Licensed under the MIT license; A copy of the license that can be
# found in the LICENSE file.
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# The global variable that holds the menu object
unset MENUEX
declare -A MENUEX=()

# Change to 'Debug' for logs to be shown
MENUEX['build']='Debug'
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
#
# Functions and parameters acronims
#
# [IN]  - input argument
# [OPT] - optional argument
# [OUT] - output result
#
# MENU_Null - is a special string that represents 'no string' for an optional
#             string argument; it can be usefull when an optional string
#             argument is in the middle of the arguments list, For example:
#             "MENU_Create menu1 MENU_Null MENU_Null Menu1Function". In case of
#             "MENU_Create menu1 '' '' Menu1Function" it would be impossible to
#             separate one parameter from the others inside the function
#
# MENU_lover_case - functions, named in such a way, are private and are not
#                    supposed to be called directly, but nothing prevents it
#
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# Helper functions to display log/trace
#
# [IN] string - a log's mode, supported: {INFO, WARNING, SEVERE}
#
# -----------------------------------------------------------------------------
MENU_log() {
    eval "${MENUEX['styles']}"

    local marker
    case $1 in
        INFO)
            marker="\e[48;5;${styles['black']}m\e[38;5;${styles['light.green']}m"
            ;;
        WARNING)
            marker="\e[48;5;${styles['black']}m\e[38;5;${styles['light.yellow']}m"
            ;;
        SEVERE)
            marker="\e[48;5;${styles['black']}m\e[38;5;${styles['light.red']}m"
            ;;
    esac

    printf ">${FUNCNAME[2]}: ${marker}$1: "
    shift
    printf "\e[0m"
    printf "$*\n"
}

MENU_log_ln() {
    [[ "${MENUEX["build"]}" == 'Debug' ]] && echo ''
}

MENU_log_info() {
    [[ "${MENUEX["build"]}" == 'Debug' ]] && MENU_log INFO $1
}

MENU_log_warning() {
    [[ "${MENUEX["build"]}" == 'Debug' ]] && MENU_log WARNING $1
}

MENU_error() {
  MENU_log SEVERE $1
}

MENU_warning() {
  MENU_log WARNING $1
}

# -----------------------------------------------------------------------------
# Creates a new menu
#
# [IN]      handle   - a name/handle of the menu to be used w/ the API
# [IN][OPT] name     - a displayed name of the menu
# [IN][OPT] alias    - an alias to be created that displays the menu
# [IN][OPT] callback - a function to be called when the menu is displayed
#
# Remark: The 'alias' parameter creates the alias for the menu unless the alias
#         already exists in the environment
#
# When 'callback' function is called it has 2 arguments passed in:
#
# [IN] handle - the menu's name/handle
# [IN] name   - the menu's name (if specified)
#
# -----------------------------------------------------------------------------
MENU_Create() {
    if [[ $# -lt 1 ]]; then
        MENU_error "MENU_Create requires more arguments"
        return
    fi

    local -A context=()
    context['name']='MENU_Null'
    context['alias']='MENU_Null'
    context['callback']='MENU_Null'
    context['selected']=''          # curently selected radio.button
    context['item.length.max']=0    # the max char length of an item's name
    context['MENU_width']=0         # the length of the longest string in the menu (used for menu's separator)
    context['sub.menus']='declare -a submenus=()'
    context['is.sub.menu']='false'
    context['has.sub.menu']='false'
    context['is.ln.break.last']='false'
    context['parent.menu']=''

    MENU_log_info "args: $*"

    [ $# -gt 1 ] && context['name']=$2
    [ $# -gt 2 ] && context['alias']=$3
    [ $# -gt 3 ] && context['callback']=$4

    local -a items=()
    context['items']=$(declare -p items)

    eval "${MENUEX['map']}"
    map[$1]=$(declare -p context)
    MENUEX['map']=$(declare -p map)

    eval "${MENUEX["order"]}"
    order[${#order[@]}]=$1
    MENUEX['order']=$(declare -p order)

    local default="MENU_SetStyle $1"
    ${default}

    default="MENU_SetStyleEx $1"
    ${default}

    # Create an alias to display the menu
    if [[ "${context['alias']}" != 'MENU_Null' ]]; then
        if [ `alias | grep "alias ${context['alias']}=" | wc -l` != 0 ]; then
            MENU_warning "Alias '${context['alias']}' already exists in the env and will not be reasigned!"
            [ "${MENUEX['build']}" == "Release" ] && return
        fi
        local argc="$1 ${context['name']} ${context['alias']} ${context['callback']}"
        alias "${context['alias']}"="MENU_show ${argc}"
    fi
}

MENU_colors() {
    for((i=16; i<256; i++)); do
        printf "\e[38;5;${i}m%03d" $i;
        printf "\e[0m"
        printf "\e[48;5;${i}m%03d" $i;
        printf "\e[0m"
        [ ! $((($i - 15) % 6)) -eq 0 ] && printf ' ' || printf '\n'
    done
}

# The MENU class constructor
MENU_ctor() {
    if [[ ! ${MENUEX['styles']} ]]; then
        local -A styles=()
        styles['black']=0
        styles['red']=1
        styles['green']=2
        styles['yellow']=3
        styles['blue']=4
        styles['magenta']=5
        styles['cyan']=6
        styles['light.gray']=7
        styles['dark.grey']=8
        styles['light.red']=9
        styles['light.green']=10
        styles['light.yellow']=11
        styles['light.blue']=12
        styles['light.magenta']=13
        styles['light.cyan']=14
        styles['white']=15

        # To use some cool custom colors (if your term supports it):
        # 1. run MENU_colors command in the console to see all the colors available
        # 2. deside the colors you want to use
        # 3. add them into the styles table w/ some unique names
        # 4. use MENU_StyleEx function to set the colors for the menu
        styles['custom.background']=17
        styles['custom.foreground']=8
        styles['custom.highlighter']=45

        MENUEX['styles']=$(declare -p styles)

        # Calculated width of the entire menu
        MENUEX['width.max']=0

        # A map that holds all the menus created
        MENUEX['map']='declare -A map=()'

        # Tracks the order of menus created
        MENUEX['order']='declare -a order=()'
    fi
}

MENU_ctor

# -----------------------------------------------------------------------------
# Set the style of the menu (replace the default style);
#
# For the list of standard colors, look at MENU_ctor styles[] array; there is
# also an explanation how to create and use custom colors if needed
#
# [IN]      handle              - a name/handle of the menu to be used w/ the API
# [IN][OPT] divider             - a divider to be used w/ .AddDivider ('|' by default)
# [IN][OPT] alignment           - the menu's items alignment, supported:
#            + none             : no alignment (by default)
#            + by.largest.item  : aligns all the menu's items by the length of
#                                 the largest item's name
# [IN][OPT] background.color    - the color of the background
#                                 (black by default)
# [IN][OPT] foreground.color    - the color of the text
#                                 (gray by default)
# [IN][OPT] highlighter.color   - the color of an item selected
#                                 (green by default)
# [IN][OPT] radio.button.symbol - a symbol for the radio.button selected
#                                 ('♦' by default)
# [IN][OPT] check.button.symbol - a symbol for the check.button checked
#                                 ('x' by default)
#
# Remark: 'default' can be passed as any [OPT] argument, which will set the
#         default value for the corresponding style parameter
#
# Remark: to create and use a custom color, look at MENU_ctor styles[] array
#
# Example:
#
# > MENU_SetStyle menu1 default default default default red '○'
#
# -----------------------------------------------------------------------------
MENU_SetStyle() {
    if [[ $# -lt 1 ]]; then
      MENU_error 'MENU_SetStyle requires more arguments'
      return
    fi

    eval "${MENUEX['map']}"
    eval "${map["$1"]}"

    # By default
    context['divider']='|'
    context['align']='none'
    context['background.color']='black'
    context['foreground.color']='light.gray'
    context['highlighter.color']='light.green'
    context['radio.button.symbol']='*'
    context['check.button.symbol']='x'

    # Optional arguments
    [[ $# -gt 1 && "$2" != 'default' ]] && context['divider']=$2
    [[ $# -gt 2 && "$3" != 'default' ]] && context['align']=$3
    [[ $# -gt 3 && "$4" != 'default' ]] && context['background.color']=$4
    [[ $# -gt 4 && "$5" != 'default' ]] && context['foreground.color']=$5
    [[ $# -gt 5 && "$6" != 'default' ]] && context['highlighter.color']=$6
    [[ $# -gt 6 && "$7" != 'default' ]] && context['radio.button.symbol']=$7
    [[ $# -gt 7 && "$8" != 'default' ]] && context['check.button.symbol']=$8

    map[$1]=$(declare -p context)
    MENUEX['map']=$(declare -p map)
}

# -----------------------------------------------------------------------------
# Set the extra style of the menu (replace the default style)
#
# [IN]      handle                     - a name/handle of the menu
# [IN][OPT] separator.show             - {true/false} whether to print the
#                                        menu's separator (true by default)
# [IN][OPT] separator.symbol           - '-' by default
# [IN][OPT] name.header                - ' * ' by default
# [IN][OPT] name.footer                - ':' by default
# [IN][OPT] radio.button.bracket.start - '(' by default
# [IN][OPT] radio.button.bracket.end   - ')' by default
# [IN][OPT] check.button.bracket.start - '[' by default
# [IN][OPT] check.button.bracket.end   - ']' by default
#
# Remark: 'default' can be passed as any [OPT] argument, which will set the
#         default value for the corresponding style parameter
#
# -----------------------------------------------------------------------------
MENU_SetStyleEx() {
    if [[ $# -lt 1 ]]; then
      MENU_error 'MENU_SetStyle requires more arguments'
      return
    fi

    eval "${MENUEX['map']}"
    eval "${map["$1"]}"

    # By default
    context['separator.show']='true'
    context['separator.symbol']='-'
    context['name.header']=' * '
    context['name.footer']=':'
    context['radio.button.bracket.start']='('
    context['radio.button.bracket.end']=')'
    context['check.button.bracket.start']='['
    context['check.button.bracket.end']=']'

    # Optional arguments
    [[ $# -gt 1 && "$2" != 'default' ]] && context['separator.show']=$2
    [[ $# -gt 2 && "$3" != 'default' ]] && context['separator.symbol']=$3
    [[ $# -gt 3 && "$4" != 'default' ]] && context['name.header']=$4
    [[ $# -gt 4 && "$5" != 'default' ]] && context['name.footer']=$5
    [[ $# -gt 5 && "$6" != 'default' ]] && context['radio.button.bracket.start']=$6
    [[ $# -gt 6 && "$7" != 'default' ]] && context['radio.button.bracket.end']=$7
    [[ $# -gt 7 && "$8" != 'default' ]] && context['check.button.bracket.start']=$8
    [[ $# -gt 8 && "$9" != 'default' ]] && context['check.button.bracket.end']=$9

    map[$1]=$(declare -p context)
    MENUEX['map']=$(declare -p map)
}

# -----------------------------------------------------------------------------
# Add a child menu into the parent MENU_ Allows to create independently
# operating radio buttons in the same menu
#
# [IN] parent - name of the main (parent) menu
# [IN] child  - a menu to serve as a sub (child) menu for the parent menu
#
# Remark: When a menu becomes a child menu it style changes automatically and
# it looses some of its properties, like 'name', 'header', 'footer', and the
# main menu's 'alias'
#
# -----------------------------------------------------------------------------
MENU_AddMenu() {
    if [[ $# -ne 2 ]]; then
        MENU_error "MENU_AddMenu requires more arguments"
        return
    fi

    eval "${MENUEX['map']}"

    eval "${map["$1"]}"
    if [[ "${context['is.sub.menu']}" == "true" ]]; then
        MENU_error "Nesting is not supported! 'parent' ['$1'] is a child menu itself."
        return
    fi

    eval "${map["$2"]}"
    if [ ${#context[@]} -eq 0 ]; then
        MENU_error "No sub menu '$2' has been found!"
        return
    fi

    context['is.sub.menu']=true
    context['parent.menu']=$1

    # Since menu $2 will be a sub menu it will not have those fields:
    # 'name', name's header and footer, and 'alias'
    context['name']='MENU_Null'
    context['name.header']=''
    context['name.footer']=''

    # If 'alias' was created then we have to delete it
    if [ "${context['alias']}" != '' ]; then
        if [ `alias | grep "alias ${context['alias']}=" | wc -l` != 0 ]; then
            unalias "${context['alias']}"
        fi
    fi

    context['alias']='MENU_Null'

    map[$2]=$(declare -p context)
    MENUEX['map']=$(declare -p map)

    eval "${map["$1"]}"
    if [ ${#context[@]} -eq 0 ]; then
        MENU_error "No main menu '$1' has been found!"
        return
    fi

    eval "${context['sub.menus']}"
    submenus["${#submenus[@]}"]=$2

    context['has.sub.menu']='true'
    context['sub.menus']=$(declare -p submenus)

    map[$1]=$(declare -p context)
    MENUEX['map']=$(declare -p map)
}

# -----------------------------------------------------------------------------
# [IN] type - the type of an item to be added, supported types:
#       {radio.button, check.button, divider, ln.break}
#
# [IN] $* - the rest of arguments comes from the public .Add function
#
# -----------------------------------------------------------------------------
MENU_add_item() {
    if [[ $# -lt 2 ]]; then
        MENU_error "MENU_add_item requires more arguments"
        return
    fi

    MENU_log_info "args: $*"

    eval item_name="$3"

    local -A item=()
    item['type']=$1
    item['name']=$item_name
    item['checked']='false' # used for 'check.button' items only
    item['alias']='MENU_Null'
    item['callback']='MENU_Null'

    # Optional arguments
    [ $# -gt 3 ] && item['alias']=$4
    [ $# -gt 4 ] && item['callback']=$5

    eval "${MENUEX['map']}"
    eval "${map["$2"]}"
    eval "${context['items']}"

    items[${#items[@]}]=$(declare -p item)
    context['items']=$(declare -p items)

    [ "${item['type']}" == 'ln.break' ] && context['is.ln.break.last']='true' || context['is.ln.break.last']='false'

    # Used for 'by.largest.item' alignment since we need to know what item's length is the longest one
    [[ ${context['item.length.max']} -lt ${#item['name']} ]] && context['item.length.max']=${#item['name']}

    map[$2]=$(declare -p context)
    MENUEX['map']=$(declare -p map)

    [[ "${item['type']}" != 'radio.button' && "${item['type']}" != 'check.button' ]] && return

    # Create an alias to call the menu's callback
    if [[ "${item['alias']}" != 'MENU_Null' ]] && [[ "${item['callback']}" != 'MENU_Null' ]]; then
        if [ `alias | grep "alias ${item['alias']}=" | wc -l` != 0 ]; then
            MENU_warning "Alias '${item['alias']}' already exists in the env and will not be reasigned!"
            [[ "${MENUEX['build']}" == 'Release' ]] && return
        fi

        [[ "${item['type']}" == 'radio.button' ]] && local f2='true' || local f2='false'
        alias "${item['alias']}"="MENU_select $2 \"${item['name']}\" $f2"
    fi
}

# -----------------------------------------------------------------------------
# Add a radio button into a menu
#
# [IN]      handle   - a handle to the menu
# [IN]      name     - a name of the radio button to be added into the menu;
#                      name w/ spaces is suported, e.g. 'Box mode 1'
# [IN][OPT] alias    - an alias to be created that selects the radio button;
#                      alias cannot have spaces in the alias' name
# [IN][OPT] callback - a function to be called when the button is selected
#
# Remark: The 'alias' parameter creates the alias for the item unless the alias
#         already exists in the environment; If 'alias' is part of the name,
#         for example name = 'MyItem1' and alias = 'em1', then the alias 'em1'
#         will be hightlighted (underlined) when displayed.
#
# Remark: When 'callback' function is called it has 3 arguments passed in:
#
# Callback():
#   $1 [IN]      handle - the menu's name/handle
#   $2 [IN]      name   - the name of the selected item
#   $3 [IN][OPT] state  - {on, off} item's state (check.button type only)
#
# Example:
#
# > MENU_AddRadioButton MyMenu1 Item1 m1 Menu1Item1_Cb
# > MENU_AddRadioButton MyMenu1 Item2 m2 Menu1Item2_Cb
#
# -----------------------------------------------------------------------------
MENU_AddRadioButton() {
    # A trick to pass an item's name string as a variable to be able
    # to use spaces in the name string, e.g. "Menu Item 1"
    local menu_name=$1
    local item_name="$2"
    shift 2
    local cmd="MENU_add_item radio.button $menu_name \"\${item_name}\" $*"
    ${cmd}
}

# -----------------------------------------------------------------------------
# Add a check button into a menu
#
# Remark: look AddRadioButton documentation for the parameters description
#
# -----------------------------------------------------------------------------
MENU_AddCheckButton() {
    local menu_name=$1
    local item_name="$2"
    shift 2
    local cmd="MENU_add_item check.button $menu_name \"\${item_name}\" $*"
    ${cmd}
}

# -----------------------------------------------------------------------------
# Add a line break into a menu
#
# [IN] handle - a handle to the menu
#
# -----------------------------------------------------------------------------
MENU_AddLnBreak() {
    local cmd="MENU_add_item ln.break $*"
    ${cmd}
}

# -----------------------------------------------------------------------------
# Add a label (simple text) into a menu
#
# [IN] handle - a handle to the menu
# [IN] label  - a text (lable) to be added into the menu
#
# -----------------------------------------------------------------------------
MENU_AddLabel() {
    local menu_name=$1
    local item_name="$2"
    shift 2
    local cmd="MENU_add_item label $menu_name \"\${item_name}\" $*"
    ${cmd}
}

# -----------------------------------------------------------------------------
# Add a label (simple text) into a menu
#
# [IN] handle - a handle to the menu
#
# -----------------------------------------------------------------------------
MENU_AddDivider() {
    local cmd="MENU_add_item divider $*"
    ${cmd}
}

# -----------------------------------------------------------------------------
# Mark an item in the menu as selected, for a radio button, or checked, for
# a check button
#
# [IN] handle - a handle to the menu
# [IN] name   - name of the item to be marked as selected
#
# The rest of the arguments are 'false' by default:
#
# [IN][OPT] show  - {true, false} whether to display the menu
# [IN][OPT] flag1 - {true, false} whether to call the main menu's callback
# [IN][OPT] flag2 - {true, false} whether to call the selected item's callback
# [IN][OPT] mode  - call-mode of all the check button item's callbacks:
#            + all(true) : call the callbacks of all the check buttons
#            + no(false) : do not call the check button's callbacks
#            + on        : call the callbacks of all the check buttons
#                          in the 'on' (checked) state
#            + off       : call the callbacks of all the check buttons
#                          in the 'off' (unchecked) state
#
# Remark: By default, .Select simply marks the item as selected and it does not
# display the menu or trigger the item's callback
#
# DEMO: For example, the following command selects 'Release' radio button in
#       the demo 'Build' menu, shows the 'Build' menu, and calls the 'Release'
#       radio.button's callbacks:
#
# > MENU_Select build_menu Release true false true
#
# -----------------------------------------------------------------------------
MENU_Select() {
    if [[ $# -lt 2 ]]; then
        MENU_error 'MENU_Select requires more arguments'
        return
    fi

    eval "${MENUEX['map']}"
    eval "${map["$1"]}"

    MENU_log_info "ARGS: $*"
    [[ $# -gt 2 ]] && local show=$3 || local show='false'

    # current_item is used for a child menu trick to call only one callback of
    # the selected radio/check button and do not to call all the callbacks of
    # all the radio/check buttons of all child menus
    current_item="$2"

    # We have to go through items[] first to check whether
    # the selected item is a check button type item
    eval "${context['items']}"
    local check_button_set
    for i in "${!items[@]}"; do
        eval "${items["$i"]}"
        if [[ "${item['name']}" == $2 ]] && [[ "${item['type']}" == 'check.button' ]]; then
            [[ "${item['checked']}" == 'true' ]] && item['checked']='false' || item['checked']='true'
            items["$i"]=$(declare -p item)
            context['items']=$(declare -p items)
            MENU_log_info "CHECK BOX: '$current_item' state='${item['checked']}'"
            check_button_set='true'
            break
        fi
    done

    # Set selected if the itme's type is the radio.button
    if [[ ! "$check_button_set" ]]; then
        context['selected']=$2
    fi

    map[$1]=$(declare -p context)
    MENUEX['map']=$(declare -p map)

    [[ $# -gt 3 ]] && flag1=$4 || flag1='false'
    [[ $# -gt 4 ]] && flag2=$5 || flag2='false'
    [[ $# -gt 5 ]] && mode=$6 || mode='false'

    # When called from an alias of an item there is an optional extra argument
    # true/false whether to call the main menu's callback in addition
    [[ $# -gt 6 ]] && flag1=$7

    if [ "$show" == 'true' ]; then
        MENU_log_info "Show $1 f1=$flag1 f2=$flag2 mode=$mode"
        MENU_Show $1 $flag1 $flag2 $mode
        current_item=''
    fi
}

# arguments are comming from the item's alias: $*
MENU_select() {
    MENU_log_info "ARGS: $*"

    [[ $# -gt 2 ]] && local f2=$3 || local f2='false'

    # an extra {true/false} might come from an alias argument
    # to call the main menu's callback
    [[ $# -gt 3 ]] && local f1=$4 || local f1='false'

    MENU_Select $1 "$2"

    MENU_separator $1
    MENU_Show $1 $f1 $f2 current
    MENU_separator $1

    current_item=''
}

# -----------------------------------------------------------------------------
# Performs an operation for all the check button items in the menu
#
# [IN] name      - a handle to the menu
# [IN] operation - a type of operation to be performed on all the check buttons
#       + on   : check all the check.button items
#       + off  : un-check all the check.button itmes
#       + flip : flip the state of all the check.button itmes
#
# The rest of the arguments are 'false' by default:
#
# [IN][OPT] show  - {true, false} whether to display the menu
# [IN][OPT] flag1 - {true, false} whether to call the main manu's callback
# [IN][OPT] flag2 - {true, false} whether to call the selected item's callback
# [IN][OPT] mode  - call-mode of all the check button item's callbacks;
#                   look at .Select documentation for mode options
#
# DEMO: For example, the following command flips all the check buttons in the
#       demo 'Build' menu, shows the 'Build' menu, and calls all the 'on'
#       (checked) check button's callbacks:
#
# > MENU_CheckButtonForAll build_menu flip true false false on
#
# -----------------------------------------------------------------------------
MENU_CheckButtonForAll() {
    if [ $# -lt 2 ]; then
        MENU_error "MENU_CheckButtonForAll requires more arguments"
        return
    fi

    MENU_log_info "ARGS: $*"

    eval "${MENUEX['map']}"
    eval "${map["$1"]}"
    eval "${context['items']}"

    local changed='false'
    for i in "${!items[@]}"; do
        eval "${items["$i"]}"

        [ "${item['type']}" != 'check.button' ] && continue;

        local updated='false'
        case $2 in
            check)
                [ "${item["checked"]}" == 'false' ] && item['checked']='true'; updated='true'
                ;;
            uncheck)
                [ "${item["checked"]}" == 'true' ] && item['checked']='false'; updated='true'
                ;;
            flip)
                [ "${item["checked"]}" == 'true' ] && item['checked']='false' || item['checked']='true'
                updated='true'
                ;;
        esac
        [ "$updated" == 'true' ] && items["$i"]=$(declare -p item); context['items']=$(declare -p items); changed='true'
    done

    if [[ "$changed" == 'true' ]]; then
        map[$1]=$(declare -p context)
        MENUEX['map']=$(declare -p map)
    fi

    [[ $# -gt 2 ]] && show=$3 || show='false'
    [[ $# -gt 3 ]] && flag1=$4 || flag1='false'
    [[ $# -gt 4 ]] && flag2=$5 || flag1='false'
    [[ $# -gt 5 ]] && mode=$6 || mode='false'

    if [ "$show" == 'true' ]; then
        MENU_Show $1 $flag1 $flag2 $mode
    fi
}

# -----------------------------------------------------------------------------
# Display the menu
#
# [IN] name - a handle to the menu
#
# The rest of the arguments are 'false' by default:
#
# [IN][OPT] flag1 - {true, false} whether to call the main menu's callback
# [IN][OPT] flag2 - {true, false} whether to call the selected item's callback
# [IN][OPT] mode  - call-mode of all the check button item's callbacks:
#            + all (true) : call the callbacks of all the check buttons
#                           regardless of its state
#            + no( false) : do not call the check button's callbacks
#            + on         : call the callbacks of all the check buttons
#                           in the 'on' (checked) state
#            + off        : call the callbacks of all the check buttons
#                           in the 'off' (unchecked) state
#
# DEMO: For example, the following command simply shows/displays the demo
#       'PLATFORM' menu w/o calling any callbacks:
#
# > MENU_Show pl_menu
#
# -----------------------------------------------------------------------------
MENU_Show() {
    if [ $# -lt 1 ]; then
        MENU_error 'MENU_Show requires more arguments'
        return
    fi

    __args=("$@")
    MENU_log_info "ARGS: $*"

    eval "${MENUEX['map']}"
    eval "${MENUEX['styles']}"
    eval "${map["$1"]}"

    if [ "${context['is.sub.menu']}" == 'true' ]; then
        local parent=${context['parent.menu']}
        MENU_log_warning "'$1' is a sub MENU_ Show the parent '$parent' menu instead"
        eval "${map["$parent"]}"
    fi

    local -a callbacks=()
    local -a arguments=()
    local idx=0

    [[ $# -gt 1 ]] && local flag1=$2 || local flag1='false'
    [[ $# -gt 2 ]] && local flag2=$3 || local flag2='false'
    [[ $# -gt 3 ]] && local mode=$4 || local mode='false'

    # Is used to 'space'-pad the menu after line break
    local pheader_pad_sz=0
    if [ "${context['name']}" != 'MENU_Null' ]; then
        pheader_pad_sz=${#context['name']}
        ((pheader_pad_sz += ${#context['name.header']} + ${#context['name.footer']} + 1))
    fi

    eval "${context['sub.menus']}"
    local parent_sub_menus=("${submenus[@]}")
    local sub_menu_count=$((${#submenus[@]}))
    local is_parent_ln_break=${context['is.ln.break.last']}
    local sub_menu_index=0

    local has_sub_menu='false'
    if [ "${context['has.sub.menu']}" == "true" ] && [ $sub_menu_count -gt 0 ]; then
        has_sub_menu='true'
    fi

    local color="\e[48;5;${styles[${context['background.color']}]}m\e[38;5;${styles[${context['foreground.color']}]}m"
    local smul="\e[4m"
    local rmul="\e[24m"

    while true; do
        eval "${context['items']}"

        if [ "${context['name']}" != 'MENU_Null' ]; then
            printf "$color${context['name.header']}${context['name']/${context['alias']}/$smul${context['alias']}$rmul}"
            printf "${context['name.footer']} "
        fi

        # Store the main menu's callback to be called later
        if [ "$flag1" == 'true' ] && [ "${context['callback']}" != 'MENU_Null' ]; then
            callbacks[$idx]=${context['callback']}
            [[ "${context['name']}" != 'MENU_Null' ]] && arguments[$idx]+="$1 ${context['name']}" || arguments[$idx]="$1"
            ((idx++))
        fi

        # The number of spaces needed to cover the empty radio/check.button box; for example: [' '] one space
        # if symbol 'x' is 1 char, and 3 spaces ['   '] if button symbol is 'xxx' 3 chars
        local check_pad_sz=${#context['check.button.symbol']}
        local radio_pad_sz=${#context['radio.button.symbol']}

        if [ "$show_alias" == 'true' ]; then
            printf "\n"
        fi

        local total=${#items[@]}
        for i in "${!items[@]}"; do
            eval "${items["$i"]}"

            local name=${item['name']}
            if [ "$show_alias" == 'true' ]; then
                if [ "${item['alias']}" != 'MENU_Null' ]; then
                    name+=" - '${item['alias']}'"
                fi
                printf "   > $name\n"
                continue
            fi

            # Calculate how many spaces we have to add after the menu's item name
            # in order to have all items to be aligned by the longest one
            local name_pad_sz=1
            if [ "${context['align']}" == 'by.largest.item' ] && [ "${item['type']}" != 'label' ]; then
                ((name_pad_sz += ${context['item.length.max']} - ${#name}))
            fi

            local type=${item['type']}
            if [ "$type" == 'ln.break' ]; then
                printf "\n"
                if [ "${context['name']}" != 'MENU_Null' ] || [ "${context['is.sub.menu']}" == 'true' ]; then
                    printf $color"%*s" $pheader_pad_sz
                fi
                continue
            fi

            local alias=${item['alias']}
            local highlighter="\e[48;5;${styles[${context['background.color']}]}m\e[38;5;${styles[${context['highlighter.color']}]}m"
            local selected=${context['selected']}

            if [ "$type" == 'label' ]; then
                printf ${color}"${name}%*s" $name_pad_sz
                continue;
            fi

            if [ "$type" == 'divider' ]; then
                local divider=${context['divider']}
                printf "$divider "
                continue;
            fi

            if [ "$type" == 'radio.button' ]; then
                if [ "${item['name']}" == "$selected" ]; then
                    local hi=${highlighter}$smul${item['alias']}$rmul

                    # '(*) Name '
                    printf "${highlighter}${context['radio.button.bracket.start']}"
                    printf "${context['radio.button.symbol']}${context['radio.button.bracket.end']} "
                    printf "${name/$alias/$hi}%*s" $name_pad_sz
                    printf "\e[0m"

                    # Store the radio button item's callback to be called later
                    MENU_log_ln
                    MENU_log_warning "current_item: $current_item, mode: $mode, flag2=$flag2"

                    local add_callback='false'
                    if [ "${item['callback']}" != 'MENU_Null' ]; then
                        if [ "$mode" == 'current' ]; then
                            [ "$current_item" == "${item['name']}" ] && add_callback='true'
                        else
                            [ "$flag2" == 'true' ] && add_callback='true'
                        fi
                    fi

                    if [ "$add_callback" == 'true' ]; then
                        callbacks[$idx]=${item['callback']}
                        arguments[$idx]="$1 ${item['name']}"
                        ((idx++))
                        echo "1========================> ${#callbacks[@]}"
                    fi
                else
                    # '( ) Name '
                    printf "${color}${context['radio.button.bracket.start']}"
                    printf "%*s" $radio_pad_sz
                    printf "${context['radio.button.bracket.end']} "
                    printf "${name/$alias/$smul$alias$rmul}%*s" $name_pad_sz
                fi

                continue;
            fi

            if [ "$type" == 'check.button' ]; then
                if [ "${item['checked']}" == 'true' ]; then
                    local hi=${highlighter}$smul${item['alias']}$rmul

                    # '[x] Name '
                    printf "${highlighter}${context['check.button.bracket.start']}${context['check.button.symbol']}"
                    printf "${context['check.button.bracket.end']} "
                    printf "${name/$alias/$hi}%*s" $name_pad_sz
                    printf "\e[0m"

                    if [ "$mode" == 'true' ] && [ "${context['callback']}" != 'MENU_Null' ]; then
                        callbacks[$idx]=${item['callback']}
                        arguments[$idx]="$1 ${item['name']} ${item['checked']}"
                        ((idx++))
                        echo "2========================> ${#callbacks[@]}"
                    fi
                else
                    # '[ ] Name '
                    printf "${color}${context['check.button.bracket.start']}"
                    printf "%*s" $check_pad_sz
                    printf "${context['check.button.bracket.end']} "
                    printf "${name/$alias/$smul$alias$rmul}%*s" $name_pad_sz

                    if [ "$mode" == 'false' ] && [ "${context['callback']}" != 'MENU_Null' ]; then
                        callbacks[$idx]=${item['callback']}
                        arguments[$idx]="$1 ${item['name']} ${item['checked']}"
                        ((idx++))
                        echo "3========================> ${#callbacks[@]}"
                    fi
                fi

                MENU_log_ln
                MENU_log_warning "mode: $mode current_item: $current_item"
                MENU_log_info "${item['callback']} ${item['name']} ${item['checked']}"

                local add_callback='false'
                if [ "${item['callback']}" != 'MENU_Null' ]; then
                    if [ "$mode" == 'current' ]; then
                        [ "$current_item" == "${item['name']}" ] && add_callback='true'
                    else
                        if [ "$mode" == 'true' ] || [ "$mode" == 'all' ]; then
                            add_callback='true'
                        fi
                    fi
                fi

                MENU_log_warning "add_callback: $add_callback"

                if [ "$add_callback" == 'true' ]; then
                    callbacks[$idx]=${item['callback']}
                    arguments[$idx]="$1 ${item['name']} ${item['checked']}"
                    ((idx++))
                    echo "4========================> ${#callbacks[@]}"
                fi

                continue;
            fi
        done

        # if parent has sub-menus then unpack sub menu each by each and print it all
        if [ "$has_sub_menu" == 'true' ]; then
            if [[ $sub_menu_count -gt $sub_menu_index ]]; then
                if [ "$is_parent_ln_break" == 'true' ] && [ $sub_menu_index -gt 0 ]; then
                    printf "\n%*s" $pheader_pad_sz
                fi
                local subname=${parent_sub_menus["$sub_menu_index"]}
                eval "${map["$subname"]}"
                ((sub_menu_index++))
                continue
            fi
        fi

        break
    done

    printf "\e[0m"
    printf "\n"

    ELEMENTS=${#__args[@]}
    for ((i=0;i<$ELEMENTS;i++)); do
        echo ${__args[${i}]}
    done

    # Last, call all the callbacks with its arguments that needs to be called
    for i in "${!callbacks[@]}"; do
        cb=${callbacks[$i]}
        [[ "${arguments[$i]}" ]] && cb+=" ${arguments[$i]}"
        ${cb}
    done
}

# -----------------------------------------------------------------------------
# Displays all the menus created
#
# All the optional arguments are 'false' by default:
#
# [IN][OPT] order - {true/false} whether to display all the menus in the order
#           of how the menus were created
# [IN][OPT] flag1 - {true/false} whether to call the main manu's callback
# [IN][OPT] flag2 - {true/false} whether to call the selected item's callback
# [IN][OPT] mode  - call-mode of all the check.button item's callbacks
#
# Remark: By default, the displaying order of the menus corresponds to the
#         order of how the keys of the bash's assosiative array are sorted
#
# -----------------------------------------------------------------------------
MENU_ShowAll() {
    [[ $# -gt 0 ]] && order=$1 || order='false'
    [[ $# -gt 1 ]] && f1=$2 || f1='false'
    [[ $# -gt 2 ]] && f2=$3 || f2='false'
    [[ $# -gt 3 ]] && mode=$4 || mode='false'

    local last_menu=''
    if [ "$order" == 'true' ]; then
        eval "${MENUEX['order']}"
        for i in "${!order[@]}"; do
            last_menu=${order[$i]}

            eval "${MENUEX['map']}"
            eval "${map["$last_menu"]}"
            [ "${context['is.sub.menu']}" == 'true' ] && continue

            MENU_separator $last_menu true
            MENU_Show $last_menu $f1 $f2 $mode
        done
    else
        eval "${MENUEX['map']}"
        for menu in "${!map[@]}"; do
            eval "${map["$menu"]}"

            [ "${context['is.sub.menu']}" == 'true' ] && continue

            last_menu=$menu
            MENU_separator $menu true
            MENU_Show $menu $f1 $f2 $mode
        done
    fi

    MENU_separator $last_menu true
}

# -----------------------------------------------------------------------------
# The lenght of the separator needs to be dynamically calculated because of such
# factors as ln.break, alignment, and customizable chars for the radio/check
# buttons
#
# [IN]  name   - the menu's handle
# [OUT] length - the length of the menu
#
# -----------------------------------------------------------------------------
MENU_calculate_menu_width() {
    if [ $# -lt 1 ]; then
        MENU_error 'MENU_calculate_menu_width requires more arguments'
        return
    fi

    eval "${MENUEX['map']}"
    eval "${map["$1"]}"
    eval "${context['items']}"

    local max=0
    local length=0

    for i in "${!items[@]}"; do
        eval "${items["$i"]}"

        local item_length=0
        case ${item['type']} in
            check.button | radio.button)
                [ "${context['align']}" == "by.largest.item" ] && ((item_length += ${context['item.length.max']})) || ((item_length += ${#item['name']}))
                ((item_length += ${#context["${item['type']}.bracket.start"]}))
                ((item_length += ${#context["${item['type']}.bracket.end"]}))
                ((item_length += ${#context["${item['type']}.symbol"]}))
                ((item_length += 1))
                ;;
            divider)
                ((item_length += ${#context['divider']}))
                ;;
            label)
                ((item_length += ${#item['name']}))
                ;;
            ln.break)
                [ $length -gt $max ] && max=$length
                length=0
                continue
                ;;
        esac

        ((item_length += 1)) # one space ' ' after each item's name
        ((length += $item_length))
    done

    [ $length -gt $max ] && max=$length

    local width=0
    [ $max -gt 0 ] && width=$max || width=$length

    #
    # A special corner case of [main.menu][ln.break] + [sub.menu] needs some
    # special handling because the [sub.menu] length now needs to add the length
    # of 'parent.menu' header and now the max length of the menu needs to take
    # it into account that [sub.menu] length might become the biggest length of
    # the entire menu; 'context' has 2 flags to mark this very corner case:
    # 'is.ln.break.last' and 'has.sub.menu'
    if [ "${context['is.sub.menu']}" == 'true' ]; then
        local parent="${context['parent.menu']}"
        eval "${map["$parent"]}"
        if [ "${context['is.ln.break.last']}" == 'false' ]; then
            echo $width
            return
        fi
    fi

    # When we get here the context is either the menu or the parent menu
    if [[ "${context['name']}" != 'MENU_Null' ]]; then
        ((width += ${#context['name']}))
        ((width += ${#context['name.header']}))
        ((width += ${#context['name.footer']}))
        ((width += 1)) # one space ' ' after the menu's name
    fi

    echo $width
}

# -----------------------------------------------------------------------------
# Prints out the menus' separator
#
# [IN]      menu    - the menu's handle
# [IN][OPT] largest - {true/false} whether to use the largest length
#                     of all the menus
#
# -----------------------------------------------------------------------------
MENU_separator() {
    if [ $# -lt 1 ]; then
        MENU_error 'MENU_separator requires more arguments'
        return
    fi

    local width=0

    # One time procedure; The widths of the menu have never been calculated;
    # Iterate through all the menus and calculate the width for each of the menus
    if [ ${MENUEX['width.max']} -lt 1 ]; then
        eval "${MENUEX['map']}"
        for menu in "${!map[@]}"; do
            width=$(MENU_calculate_menu_width $menu)
            [[ $width -gt ${MENUEX['width.max']} ]] && MENUEX['width.max']=$width

            MENU_log_warning "Re-calc: $menu[MENU_width]: $width"

            eval "${map["$menu"]}"

            context['MENU_width']=$width
            map[$menu]=$(declare -p context)
            MENUEX['map']=$(declare -p map)
        done

        # now let's take care of sub menus
        eval "${MENUEX['map']}"
        for menu in "${!map[@]}"; do
            eval "${map["$menu"]}"
            [ "${context['is.sub.menu']}" == 'true' ] && continue

            eval "${context['sub.menus']}"
            [ ${#submenus[@]} -eq 0 ] && continue

            local parent_ln_break=${context['is.ln.break.last']}
            width=${context['MENU_width']}
            for i in ${!submenus[@]}; do
                local subname=${submenus["$i"]}
                eval "${map[$subname]}"
                MENU_log_warning "submenus[$i]: $subname['MENU_width']: ${context['MENU_width']}"
                if [ "$parent_ln_break" == 'true' ]; then
                    [ ${context['MENU_width']} -gt $width ] && width=${context['MENU_width']}
                else
                    ((width += ${context['MENU_width']}))
                fi
            done

            MENU_log_warning "Re-calc w/ subs: $menu[MENU_width]: $width"
            [[ $width -gt ${MENUEX['width.max']} ]] && MENUEX['width.max']=$width

            # Update the new width w/ all the subs combined
            eval "${map["$menu"]}"

            context['MENU_width']=$width
            map[$menu]=$(declare -p context)
            MENUEX['map']=$(declare -p map)
        done
    fi

    eval "${MENUEX['map']}"
    eval "${MENUEX['styles']}"
    eval "${map["$1"]}"

    # if it's a sub menu then we have to use the parent's menu width
    if [ "${context['is.sub.menu']}" == 'true' ]; then
        menu=${context['parent.menu']}
        eval "${map["$menu"]}"
    fi

    width=${context['MENU_width']}

    [[ $# -gt 1 && "$2" == 'true' ]] && width=${MENUEX['width.max']}

    if [ "${context['separator.show']}" == 'true' ]; then
        ((width--)) # compensation for the way printf works
        cmd="printf -- '${context['separator.symbol']}%.0s' {1..$width}"
        printf "\e[48;5;${styles[${context['background.color']}]}m\e[38;5;${styles[${context['foreground.color']}]}m"
        eval $cmd
        printf "\e[0m"
        printf "\n"
    fi
}

# arguments are comming from the main menu's alias: $* f1 f2 mode
MENU_show() {
    [[ $# -gt 4 ]] && f1=$5 || f1='false'
    [[ $# -gt 5 ]] && f2=$6 || f2='false'
    [[ $# -gt 6 ]] && mode=$7 || mode='false'

    if [[ $# -gt 4 ]] && [[ "$5" == '-h' ]]; then
        show_alias='true'
    fi

    MENU_separator $1
    MENU_Show $1 $f1 $f2 $mode
    MENU_separator $1

    unset show_alias
}

MENU_debug_print() {
    eval "${map["$1"]}"
    eval "${MENUEX['styles']}"

    echo "* $1:"
    for ctx_key in "${!context[@]}"; do
        if [ "$ctx_key" == 'items' ]; then
            echo "  - [$ctx_key]:"
            eval "${context["$ctx_key"]}"
            for items_key in "${!items[@]}"; do
                echo "    + [$items_key]: ${items["$items_key"]}"
                eval "${items["$items_key"]}"
                for indx in "${!item[@]}"; do
                    printf "      ♦ [$indx]: ${item["$indx"]}\n"
                done
            done
        else
            printf "  - [$ctx_key]: ${context["$ctx_key"]}\n"
        fi
    done
}

MENU_debug_print_all() {
    [[ "${MENUEX['build']}" == 'Release' ]] && return

    eval "${MENUEX['map']}"
    for key in "${!map[@]}"; do
        MENU_debug_print $key
    done
}

